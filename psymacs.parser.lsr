;; This is a parser/highlighter for las3r syntax. 

;; Since paring a large string can be slow, the parser is designed to work on a token-by-token basis. The parse-next function takes a parser-state parses a single token, and returns an updated parser state (which contains a vector of all parsed tokens). It should be called several times per frame, to simulate a background thread.

;; Parser structures (maps) come in two flavors, a string parser and a textfield parser. Textfield parsers are string parsers with a :textfield key linking them to a textfield object.

;; A parser map contains these keys:
;;   :text             - the string being parsed.
;;   :parse-index      - index of the first unparsed char.
;;   :tokens           - a vector of parsed tokens (more details below).
;;   :lbracket-indices - a list of all *open* lbrackets for the current parse-index.
;;   :bracket-pairs    - a vector of token indices pairs {:l int, :r int}, contains all the matching brackets found so far, ordered by the token index of the closing rbracket.
;;   :textfield        - a textfield object (textfield-parsers only).
;;   :done             - set to true when parser is finished.

;; :lbracket-indices and :bracket-pairs exist to speed up paren-matching and context-sensitive help in the editor.

;; A parsed token (also a map) looks like this:
;;   :type       - token type (keyword).
;;   :string     - the actual content of the token.
;;   :index      - char index of the token in the parser's string.
;;   :next-index - char index of the next token (might not exist, or be parsed yet).

(las3r.core/in-ns 'psymacs.parser)
(las3r.core/refer 'las3r.core)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def #^{:private true}
     parser-regex #"#(\"(?:\\?+.)*?\")[gismx]*|(\"(?:\\?+.)*?\")|([\(\[\{])|([\)\]\}])|(;[^\r]*)|([^\s\(\[\{\}\]\)\";,]+)|([\r\s,]+)"gms)

(def #^{:private true}
     basic-token-types [:regex :string :lbracket :rbracket :comment :other :whitespace])

(defn- basic-parse
  "Initial token parser, helper for the parse fn."
  [s idx]
  (set! (. parser-regex lastIndex) idx)
  (let [m (. parser-regex (exec s))]
    (when m
      {:type (some identity (map (fn [x y] (and x y))
                                 (rest m)
                                 basic-token-types))
       :string (first m)
       :index idx
       :next-index (. parser-regex lastIndex)})))

(defn- parse
  [s idx]
  (let [token (basic-parse s idx)]
    (when token
      (if (= (token :type) :other) ;; handle numbers and keywords
        (let [reader (. *runtime* lispReader) ;; use LispReader's number matching regexes
              ts (token :string)]
          (assoc token :type
                 (cond (= (first ts) ":") :keyword
                       (re-match (. reader intPat)   ts) :int
                       (re-match (. reader floatPat) ts) :float
                       (re-match (. reader ratioPat) ts) :ratio
                       :else :other)))
        token))))

;; highlighting and textfield connectors

(def formats
     {:other      (new flash.text.TextFormat nil nil 0x000000 false) ;; default token format
      :whitespace (new flash.text.TextFormat nil nil 0xa0a0a0 true) ;; used on whitespace (and commas)
      :regex      (new flash.text.TextFormat nil nil 0x00aa22 true)
      :string     (new flash.text.TextFormat nil nil 0xaa8800 true)
      :comment    (new flash.text.TextFormat nil nil 0xcc2200 true)
      :lbracket   (new flash.text.TextFormat nil nil 0x005577 true)
      :rbracket   (new flash.text.TextFormat nil nil 0x005577 true)
      :keyword    (new flash.text.TextFormat nil nil 0x008888 true)
      :int        (new flash.text.TextFormat nil nil 0x440088 true)
      :float      (new flash.text.TextFormat nil nil 0x8800cc true)
      :ratio      (new flash.text.TextFormat nil nil 0xcc00ff true)})

(defn string-parser [s]
  {:text s
   :parse-index 0
   :tokens []
   :lbracket-indices '()
   :bracket-pairs []})
   
(defn textfield-parser [tf]
  (assoc (string-parser (. tf text)) :textfield tf))

(defn content-changed? 
  "Returns true if the textfield's content has been updated since the last call to parse-and-highlight-next!."
  [tfp]
  (not (= (tfp :text) (. (tfp :textfield) text))))

(defn update-tfp
  "Returns an up-to-date parser (in case the textfield's content has changed)."
  [tfp]
  (if (content-changed? tfp)
    (textfield-parser (tfp :textfield)) ;; TODO - reuse viable data
    tfp))

(defn parse-next [parser]
  "Parses the next token, returns updated parser."
  (if (parser :done)
    parser
    (let [token (parse (parser :text) (parser :parse-index))]
      (if token
	(merge parser
	       {:parse-index 
		(token :next-index)
		
		:tokens 
		(conj (parser :tokens) (assoc token :prev-lbracket ;; save prev-labracket in token
					      (first (parser :lbracket-indices))))

		:lbracket-indices
		(cond (= (token :type) :lbracket)
		      (cons (count (parser :tokens)) (parser :lbracket-indices))
		      
		      (= (token :type) :rbracket)
		      (rest (parser :lbracket-indices))

		      :else
		      (parser :lbracket-indices))

		:bracket-pairs
		(if (and (= (token :type) :rbracket) ;; if we're at an rbracket,
			 (seq (parser :lbracket-indices))) ;; and an open lbracket exists -
		  ;; insert their indices into the bracket-pairs vector
		  (conj (parser :bracket-pairs) 
			{:l (first (parser :lbracket-indices))
			 :r (count (parser :tokens))})
		  (parser :bracket-pairs))})
	(assoc parser :done true)))))

(defn highlight-last! [tfp]
  "Highlights the last parsed token."
  (let [token (last (tfp :tokens))]
    (when token
      (. (tfp :textfield) (setTextFormat (formats (token :type))
					 (token :index)
					 (token :next-index))))))

(defn parse-and-highlight-next! 
  "Returns a new parser state."
  [tfp]
    (let [tfp (parse-next (update-tfp tfp))]
      (if (not (tfp :done))
	(highlight-last! tfp))
      tfp))

;; testing

(def tf nil)
(def tfp nil)

(defn test-tfp []
  (def tf (new flash.text.TextField))
  (def tfp (textfield-parser tf))
  (set! (. tf width) 300)
  (set! (. tf height) 300)
  (set! (. tf x) 500)
  (set! (. tf y) 100)
  (set! (. tf background) true)
  (set! (. tf backgroundColor) 0xeeeeee)
  (set! (. tf multiline) true)
  (set! (. tf type) "input")
  (set! (. tf defaultTextFormat) (new flash.text.TextFormat "Courier New", 13, 0x000000))
  
  (. *stage* (addEventListener "enterFrame" 
                               (fn [_] 
                                 (def tfp (parse-and-highlight-next! tfp))
                                 #_ (psymacs/clear-mini-buffer!)
                                 #_ (prn "tfp:" tfp))))
  (. *stage* (addChild tf)))

(test-tfp)
