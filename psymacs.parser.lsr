;; TODO: seperate files, compiler, etc...

(las3r.core/in-ns 'psymacs.utils)
(las3r.core/refer 'las3r.core :exclude '(run-tests))

(def #^{:private true} log-div (. Math (log 2)))
(defmacro #^{:private true} log2 [x] `(/ (. Math (log ~x)) log-div))

(defn vlast 
  "Returns the last element of a vector. Fast."
  [v]
  (when (seq v)
    (v (dec (count v)))))

(defn common-prefix-length [s1 s2]
  (let [min-length (min (count s1) (count s2))]
    (min (loop [step (. Math (pow 2 (. Math (floor (log2 min-length)))))
                l 0]
           (if (< l min-length)
             (if (= (. s1 (substr 0 (+ l step))) (. s2 (substr 0 (+ l step))))
               (recur step (+ l step))
               (if (= step 1)
                 l
                 (recur (bit-shr step 1) l)))
             l))
         min-length)))

(defn binary-search
  "Takes data (should be a sorted vector), and an under-value? predicate function. Returns the index of the match or nil."
  [data under-value?]
  (if (seq data) ;; skip if vector is empty
    (loop [lo 0
           hi (dec (count data))]
      (if (< lo hi)
        (let [mid (+ lo (bit-shr (- hi lo) 1))]
          (if (under-value? (nth data mid))
            (recur (inc mid) hi)
            (recur lo mid)))
        (and (not (under-value? (nth data lo))) lo)))))

(def *char-width* 7)
(def *char-height* 14)
(defn char-xy
  "Returns the [x y] coordinates of the char at the specified index. Compensates for textfield scrolling."
  [tf idx]
  (let [char-row (. tf (getLineIndexOfChar idx))
	line-offset (. tf (getLineOffset char-row))
	char-col (- idx line-offset)]
    [(+ 2 (- (* *char-width* char-col) (. tf scrollH)))
     (+ 2 (* *char-height* (- char-row (dec (. tf scrollV)))))]))

(defn matching-bracket
  "Returns c's matching bracket or nil."
  [c]
  (get {"(" ")", ")" "(", "[" "]", "]" "[", "{" "}", "}" "{"} c))

(defn matching-brackets? [x y]
  (= (matching-bracket x) y))

(defn run-tests []
  ;; common-prefix-length tests
  (assert-true (= (common-prefix-length "Hello World", "Hello World") 11))
  (assert-true (= (common-prefix-length "Hello World", "Hello! World") 5))
  (assert-true (= (common-prefix-length "Hello World", "HelPIYOrld") 3))
  (assert-true (= (common-prefix-length "a", "aB") 1))
  (assert-true (= (common-prefix-length "aBC", "aBCD") 3))
  (assert-true (= (common-prefix-length "Ba", "a") 0))
  (assert-true (= (common-prefix-length "aBC", "DaBC") 0))
  (assert-true (= (common-prefix-length "aXbXc", "aXc") 2))
  (assert-true (= (common-prefix-length "aaaXccc", "aaaXbbbXccc") 4)))



;; This is a parser/highlighter for las3r syntax.

;; Since paring a large string can be slow, the parser is designed to
;; work on a token-by-token basis. The parse-next function takes a
;; parser-state, parses a single token, and returns an updated parser
;; state (which contains a vector of all parsed tokens). It should be
;; called several times per frame, to simulate a background thread.

;; Parser structures (maps) come in two flavors, a string parser and a
;; textfield parser. Textfield parsers are string parsers with a
;; :textfield key linking them to a textfield object.

;; A parser map contains these keys:
;;   :text             - the string being parsed.
;;   :tokens           - a vector of parsed tokens (more details below).
;;   :textfield        - a textfield object (textfield-parsers only).
;;   :done             - set to true when parser is finished.

;; A parsed token (also a map) looks like this:
;;   :type          - token type (keyword).
;;   :string        - the actual content of the token.
;;   :index         - char index of the token in the parser's string.
;;   :open-lbrackets - a list of all *open* lbrackets for the current parse-index.
;;   :bracket-pairs  - a vector of token indices pairs {:l int, :r int}, 
;;                    contains all the matching brackets found so far, 
;;                    ordered by the token index of the closing rbracket.
;;   :next-index    - char index of the next token (might not exist, or be parsed yet).

;; :bracket-pairs exists to speed up paren-matching and
;; context-sensitive help in the editor.

;; In order to fake being fast, when a textfield is changed, the
;; parser will skip the already parsed tokens and start at the changed
;; position (hopefully the cursor -- see update-tfp code). This means
;; we need to do some tricks to detect open strings and regexps, and
;; not just treat them as symbols.

(las3r.core/in-ns 'psymacs.parser)
(las3r.core/refer 'psymacs.utils :exclude '(run-tests))
(las3r.core/refer 'las3r.core :exclude '(run-tests))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; big hairy parsing regex
(def #^{:private true}
     parser-regex #"#(\"(?:\\?+.)*?\")[gismx]*|([^\s\(\[\{\}\]\)\";,]+)|([\r\s,]+)|([\(\[\{])|([\)\]\}])|(\"(?:\\?+.)*?\")|(;[^\r]*)|\\(newline|tab|space|formfeed|return|u[0-9]+|[0-6]+|.)|(#?\".*)"gms)

;; these map to the big hairy regex matches
(def #^{:private true}
     basic-token-types [:regex :other :whitespace :lbracket :rbracket :string :comment :char :unmatched])

(defn- basic-parse
  "Initial token parser, helper for the parse fn."
  [s idx]
  (set! (. parser-regex lastIndex) idx)
  (let [m (. parser-regex (exec s))]
    (when m
      {:type (loop [m (rest m) t basic-token-types]
               (if (first m) 
                 (first t) 
                 (recur (rest m) (rest t))))
       :string (first m)
       :index idx
       :next-index (. parser-regex lastIndex)})))

(defn- parse
  [s idx]
  (let [token (basic-parse s idx)]
    (when token
      (if (= (token :type) :other) ;; handle numbers and keywords
        (let [reader (. *runtime* lispReader) ;; use LispReader's number matching regexes
              ts (token :string)]
          (assoc token :type
                 (cond (= (first ts) ":") :keyword
                       (re-match (. reader intPat)   ts) :int
                       (re-match (. reader floatPat) ts) :float
                       (re-match (. reader ratioPat) ts) :ratio
                       :else :other)))
        token))))

(defn- parse-index
  "Returns the position of the first unparsed char."
  [parser]
  (if (seq (parser :tokens))
    ((vlast (parser :tokens)) :next-index)
    0))

;; highlighting and textfield connectors

(def formats
     {:other       (new flash.text.TextFormat nil nil 0x000000 false) ;; default token format
      :whitespace  (new flash.text.TextFormat nil nil 0xa0a0a0 true) ;; used on whitespace (and commas)
      :regex       (new flash.text.TextFormat nil nil 0x00aa22 true)
      :string      (new flash.text.TextFormat nil nil 0xaa8800 true)
      :unmatched   (new flash.text.TextFormat nil nil 0xff0000 true)
      :char        (new flash.text.TextFormat nil nil 0xccaa44 true)
      :comment     (new flash.text.TextFormat nil nil 0xcc2200 true)
      :lbracket    (new flash.text.TextFormat nil nil 0x005577 true)
      :rbracket    (new flash.text.TextFormat nil nil 0x005577 true)
      :keyword     (new flash.text.TextFormat nil nil 0x008888 true)
      :int         (new flash.text.TextFormat nil nil 0x440088 true)
      :float       (new flash.text.TextFormat nil nil 0x8800cc true)
      :ratio       (new flash.text.TextFormat nil nil 0xcc00ff true)})

(defn string-parser [s]
  {:text s
   :tokens []})

(defn last-token 
  "Takes parser, returns the last parsed token."
  [p]
  (vlast (p :tokens)))

(defn textfield-parser [tf]
  (assoc (string-parser (. tf text)) :textfield tf))

(defn char->token-index 
  "Returns the token index of the token at char-idx, or nil. "
  [parser char-idx]
  (let [token-idx (binary-search (parser :tokens)
                                 (fn [t]
                                   (<= (t :next-index) char-idx)))]
    (when token-idx ;; might be nil
      (if (>= char-idx (get-in parser [:tokens token-idx :next-index])) ;; if we're outside the token's range
        (and (parser :done) ;; char might not be parsed yet in which case we return nil,
             token-idx) ;; or we could be in an unparsable end-of-string section, so we return the last token's idx.
        token-idx))))

(defn content-changed? 
  "Returns true if the textfield's content has been updated since the last call to parse-and-highlight-next!."
  [tfp]
  (not (= (tfp :text) (. (tfp :textfield) text))))

(defn update-tfp
  "Returns an up-to-date parser (in case the textfield's content has changed)."
  [tfp]
  (if (content-changed? tfp)
    ;; (textfield-parser (tfp :textfield)) ;; debug - bypass
    ;; #_
    (let [cpl (common-prefix-length (. (tfp :textfield) text) (tfp :text))]
      (if (> cpl (parse-index tfp))
        tfp
        (let [last-good-token-idx (dec (char->token-index tfp cpl))]
          (if (and last-good-token-idx
                   (> last-good-token-idx 0))
            (merge tfp
                   {:tokens (subvec (tfp :tokens) 0 last-good-token-idx)
                    :text (. (tfp :textfield) text)
                    :done false})
            (textfield-parser (tfp :textfield))))))
    tfp))

(defn parse-next [parser]
  "Parses the next token, returns updated parser."
  (if (parser :done)
    parser
    (if-let token (parse (parser :text) (parse-index parser)) ;; get next token
      (let [type (token :type)
	    tokens (parser :tokens)
	    cnt (count tokens)
	    prev (vlast tokens)
	    
	    [p-type p-olbs p-bps] 
	    (if (seq prev)
	      [(prev :type) (prev :open-lbrackets) (prev :bracket-pairs)]
	      [nil '() []])

	    ;; new open-lbrackets list
	    olbs (cond (= p-type :lbracket)
		       (cons (dec cnt) p-olbs)
		       
		       (= p-type :rbracket)
		       (rest p-olbs)
		       
		       :else
		       p-olbs)
	    ;; new bracket-pairs vector
	    bps (if (and (= type :rbracket) (seq olbs))
		  (conj p-bps {:l (first olbs) :r cnt})
		  p-bps)

	    token (assoc token :open-lbrackets olbs :bracket-pairs bps)]
	    (assoc parser :tokens (conj tokens token)))
      (assoc parser :done true))))

(defn parse-all [parser]
  (if (parser :done)
    parser
    (recur (parse-next parser))))

(defn highlight-last! [tfp]
  "Highlights the last parsed token."
  (let [token (vlast (tfp :tokens))]
    (when token
      (. (tfp :textfield) (setTextFormat (formats (token :type))
                                         (token :index)
                                         (token :next-index))))))

(defn parse-and-highlight-next! 
  "Returns a new parser state."
  [tfp]
  (let [tfp (parse-next (update-tfp tfp))]
    (if (not (tfp :done))
      (highlight-last! tfp))
    tfp))

;; testing

;; (defn run-tests []
;;   (let [tf (new flash.text.TextField)
;; 	tfp (textfield-parser tf)]

;;     (set! (. tf width) 300)
;;     (set! (. tf height) 300)
;;     (set! (. tf x) 500)
;;     (set! (. tf y) 100)
;;     (set! (. tf background) true)
;;     (set! (. tf backgroundColor) 0xeeeeee)
;;     (set! (. tf multiline) true)
;;     (set! (. tf type) "input")
;;     (set! (. tf defaultTextFormat) (new flash.text.TextFormat "Courier New", 13, 0x000000))
    
;;     (. *stage* (addEventListener "enterFrame" 
;; 				 (fn [_] 
;; 				   (def tfp (parse-and-highlight-next! tfp))
;; 				   #_ (psymacs/clear-mini-buffer!)
;; 				   #_ (prn (char->token-index tfp (. tf caretIndex)))
;; 				   #_ (prn "tfp:" tfp))))
;;     (. *stage* (addChild tf))))

;;(time (parse-all (string-parser (psymacs/editor-string))))

(las3r.core/in-ns 'psymacs.keyboard)
(las3r.core/refer 'las3r.core :exclude '(run-tests))

(defn event->keystroke [e]
  "Converts a KEY_DOWN event to a {:code ... :modifiers ...} map."
  (let [modifiers #{}
	modifiers (if (. e ctrlKey) (conj modifiers :ctrl) modifiers)
	modifiers (if (. e altKey) (conj modifiers :alt) modifiers)
	modifiers (if (. e shiftKey) (conj modifiers :shift) modifiers)]
    {:code (. e keyCode) :modifiers modifiers}))

;;;;;;;;;;;;;;;;;;;

(las3r.core/in-ns 'psymacs.main)
(las3r.core/refer 'las3r.core :exclude '(run-tests))
(las3r.core/refer 'psymacs.parser :exclude '(run-tests))
(las3r.core/refer 'psymacs.utils :exclude '(run-tests))
(las3r.core/refer 'psymacs.keyboard :exclude '(run-tests))

(def *buffers* #{})

(def *bracket-match-color* 0xAAAAAA)
(def *bracket-mismatch-color* 0xFF77AA)
(def *background-color* 0xEEEEEE)

(defn buffer-string [buffer]
  (. (buffer :textfield) text))

(defn highlight-current-sexp! [buffer]
  (let [pos (. (buffer :textfield) caretIndex)
	g (. (buffer :container) graphics)]
    (. g (clear))
    (when-let token-idx (char->token-index (buffer :parser) pos)
      (let [tokens ((buffer :parser) :tokens)
	    token (tokens token-idx)
	    bracket-pairs ((vlast tokens) :bracket-pairs)]
	(when (seq (token :open-lbrackets))
	  (when-let bp-idx (binary-search bracket-pairs ;; find 1st pair with rbracket after or at pos
					  (fn [bp] 
					    (< (bp :r) token-idx)))
	    (let [bracket-pairs (subvec bracket-pairs bp-idx)] ;; snip irrelevant bracket pairs
	      (when-let bp (some (fn [bp] (when (= (bp :l) (first (token :open-lbrackets))) bp)) bracket-pairs)
		(let [tf (buffer :textfield)
		      l ((tokens (bp :l)) :index)
		      r ((tokens (bp :r)) :index)
		      color (if (matching-brackets? ((tokens (bp :l)) :string)
						    ((tokens (bp :r)) :string))
			      *bracket-match-color*
			      *bracket-mismatch-color*)
		      highlight-char! (fn [idx]
					(let [[x y] (char-xy tf idx)]
					  (. g (beginFill color))
					  (. g (drawRect x y *char-width* *char-height*))
					  (. g (endFill))))]
		  (highlight-char! l)
		  (highlight-char! r))))))))))


;; TODO: search all namespaces?
;; (defn format-doc [fn-name]
;;   "Returns the enclosing function's documentation in the minibuffer, searches in current *ns* and 'las3r.core."
;;   []
;;   (let [name (back-search-for-context-doc)]
;;     (if name 
;;       (try
;;        (let [v (or (find-var (symbol (ns-name *ns*) name))
;; 		   (find-var (symbol 'las3r.core name)))
;;        	     arglists ((meta v) :arglists)]
;;        	 (minibuff-print-doc v))
;;        (catch Error e nil)))))

(defn docs [buffer]
  (let [caret-idx (. (buffer :textfield) caretIndex)
	pos (if (= caret-idx (count (buffer-string buffer))) ;; if we're past the last char
	      (max 0 (dec caret-idx)) ;; go one char back
	      caret-idx)]
    (prn 'pos pos)
    (when-let token-idx (char->token-index (buffer :parser) pos)
      (let [tokens ((buffer :parser) :tokens)
	    token (tokens token-idx)]
	(when-let doc-idx (some (fn [ti] 
				  (when (= ((tokens ti) :string) "(") 
				    (inc ti)))
				(token :open-lbrackets))
	  (let [fn-token (tokens doc-idx)]
	    (when (= (fn-token :type) :other)
	      (let [fn-name (fn-token :string)]
		(prn 'fn-name fn-name)))))))))

(def buff nil)
(def tf nil)

(defn- frame-handler [_] 
  (psymacs/clear-mini-buffer!)
  (def buff (assoc buff :parser (parse-and-highlight-next! (buff :parser))))
  ;; (prn (. (buff :textfield) scrollRect))
  (prn (docs buff))
  ;; (try 
  #_ (highlight-current-sexp! buff)
  ;; (catch Error e (prn (. e (getStackTrace)))))
  ;; (prn 'buff buff)

  #_ (prn (char->token-index tfp (. tf caretIndex)))
  #_ (prn "tfp:" tfp))

(defn attach-to-textfield-container
  "Returns a psymacs buffer. Container should have a readable textField property."
  [cont]
  (let [overlay (new flash.display.Sprite)]
    (. cont (addChild overlay))
    {:textfield (. cont textField)
     :container cont
     :overlay overlay
     :parser (textfield-parser tf)}))

(defn run-tests []
  (def teui (new jp.psyark.psycode.core.TextEditUI))

  (def buff (attach-to-textfield-container teui))

  (set! (. teui width) 300)
  (set! (. teui height) 300)
  (set! (. teui x) 500)
  (set! (. teui y) 100)
  ;(set! (. (buff :container) scrollRect) (new flash.geom.Rectangle 0 0 300 300))
  
  (. *stage* (addEventListener "enterFrame" frame-handler))
  (. *stage* (addChild (buff :container))))
