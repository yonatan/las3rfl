;; TODO: seperate files, compiler, etc...

(las3r.core/in-ns 'psymacs.utils)
(las3r.core/refer 'las3r.core :exclude '(run-tests))

(def #^{:private true} log-div (. Math (log 2)))
(defmacro #^{:private true} log2 [x] `(/ (. Math (log ~x)) log-div))

(defn common-prefix-length [s1 s2]
  (let [min-length (min (count s1) (count s2))]
    (min (loop [step (. Math (pow 2 (. Math (floor (log2 min-length)))))
		l 0]
	   (if (< l min-length)
	     (if (= (. s1 (substr 0 (+ l step))) (. s2 (substr 0 (+ l step))))
	       (recur step (+ l step))
	       (if (= step 1)
		 l
		 (recur (bit-shr step 1) l)))
	     l))
	 min-length)))

(defn binary-search
  "Takes data (should be a sorted vector), and an under-value? predicate function. Returns either the index of the match (or whatever is above where the match would be), or nil if given an empty vector."
  [data under-value?]
  (if (seq data) ;; skip if vector is empty
    (loop [lo 0
           hi (dec (count data))]
      (if (< lo hi)
        (let [mid (+ lo (bit-shr (- hi lo) 1))]
          (if (under-value? (nth data mid))
            (recur (inc mid) hi)
            (recur lo mid)))
        lo))))

(defn run-tests []
  ;; common-prefix-length tests
  (assert-true (= (common-prefix-length "Hello World", "Hello World") 11))
  (assert-true (= (common-prefix-length "Hello World", "Hello! World") 5))
  (assert-true (= (common-prefix-length "Hello World", "HelPIYOrld") 3))
  (assert-true (= (common-prefix-length "a", "aB") 1))
  (assert-true (= (common-prefix-length "aBC", "aBCD") 3))
  (assert-true (= (common-prefix-length "Ba", "a") 0))
  (assert-true (= (common-prefix-length "aBC", "DaBC") 0))
  (assert-true (= (common-prefix-length "aXbXc", "aXc") 2))
  (assert-true (= (common-prefix-length "aaaXccc", "aaaXbbbXccc") 4)))

;; This is a parser/highlighter for las3r syntax.

;; Since paring a large string can be slow, the parser is designed to
;; work on a token-by-token basis. The parse-next function takes a
;; parser-state, parses a single token, and returns an updated parser
;; state (which contains a vector of all parsed tokens). It should be
;; called several times per frame, to simulate a background thread.

;; Parser structures (maps) come in two flavors, a string parser and a
;; textfield parser. Textfield parsers are string parsers with a
;; :textfield key linking them to a textfield object.

;; A parser map contains these keys:
;;   :text             - the string being parsed.
;;   :tokens           - a vector of parsed tokens (more details below).
;;   :lbracket-indices - a list of all *open* lbrackets for the current parse-index.
;;   :bracket-pairs    - a vector of token indices pairs {:l int, :r int}, 
;;                       contains all the matching brackets found so far, 
;;                       ordered by the token index of the closing rbracket.
;;   :textfield        - a textfield object (textfield-parsers only).
;;   :done             - set to true when parser is finished.

;; :bracket-pairs exists to speed up paren-matching and
;; context-sensitive help in the editor.

;; A parsed token (also a map) looks like this:
;;   :type          - token type (keyword).
;;   :string        - the actual content of the token.
;;   :index         - char index of the token in the parser's string.
;;   :next-index    - char index of the next token (might not exist, or be parsed yet).
;;   :prev-lbracket - token index of the previous *open* lbracket.

;; In order to fake being fast, when a textfield is changed, the
;; parser will skip the already parsed tokens and start at the changed
;; position (hopefully the cursor -- see update-tfp code). This means
;; we need to do some tricks to detect open strings and regexps, and
;; not just treat them as symbols.

(las3r.core/in-ns 'psymacs.parser)
(las3r.core/refer 'psymacs.utils :exclude '(run-tests))
(las3r.core/refer 'las3r.core :exclude '(run-tests))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; big hairy parsing regex
(def #^{:private true}
     parser-regex #"#(\"(?:\\?+.)*?\")[gismx]*|(\"(?:\\?+.)*?\")|(\\newline|\\tab|\\space|\\formfeed|\\return|\\u[0-9]+|\\[0-6]+|\\.)|([\(\[\{])|([\)\]\}])|(;[^\r]*)|([^\s\(\[\{\}\]\)\";,]+)|([\r\s,]+)|(#?\".*)"gms)

;; these map to the big hairy regex matches
(def #^{:private true}
     basic-token-types [:regex :string :char :lbracket :rbracket :comment :other :whitespace :unmatched])

(defn- basic-parse
  "Initial token parser, helper for the parse fn."
  [s idx]
  (set! (. parser-regex lastIndex) idx)
  (let [m (. parser-regex (exec s))]
    (when m
      {:type (some identity (map (fn [x y] (and x y))
                                 (rest m)
                                 basic-token-types))
       :string (first m)
       :index idx
       :next-index (. parser-regex lastIndex)})))

(defn- parse
  [s idx]
  (let [token (basic-parse s idx)]
    (when token
      (if (= (token :type) :other) ;; handle numbers, keywords and open strings or regexes
        (let [reader (. *runtime* lispReader) ;; use LispReader's number matching regexes
              ts (token :string)]
	  (assoc token :type
		 (cond (= (first ts) ":") :keyword
		       (re-match (. reader intPat)   ts) :int
		       (re-match (. reader floatPat) ts) :float
		       (re-match (. reader ratioPat) ts) :ratio
		       :else :other)))
	token))))

(defn- parse-index
  "Returns the position of the first unparsed char."
  [parser]
  (if (seq (parser :tokens))
    ((last (parser :tokens)) :next-index)
    0))

;; highlighting and textfield connectors

(def formats
     {:other       (new flash.text.TextFormat nil nil 0x000000 false) ;; default token format
      :whitespace  (new flash.text.TextFormat nil nil 0xa0a0a0 true) ;; used on whitespace (and commas)
      :regex       (new flash.text.TextFormat nil nil 0x00aa22 true)
      :string      (new flash.text.TextFormat nil nil 0xaa8800 true)
      :unmatched   (new flash.text.TextFormat nil nil 0xff0000 true)
      :char        (new flash.text.TextFormat nil nil 0xccaa44 true)
      :comment     (new flash.text.TextFormat nil nil 0xcc2200 true)
      :lbracket    (new flash.text.TextFormat nil nil 0x005577 true)
      :rbracket    (new flash.text.TextFormat nil nil 0x005577 true)
      :keyword     (new flash.text.TextFormat nil nil 0x008888 true)
      :int         (new flash.text.TextFormat nil nil 0x440088 true)
      :float       (new flash.text.TextFormat nil nil 0x8800cc true)
      :ratio       (new flash.text.TextFormat nil nil 0xcc00ff true)})

(defn string-parser [s]
  {:text s
   :tokens []
   :lbracket-indices '()
   :bracket-pairs []})
   
(defn textfield-parser [tf]
  (assoc (string-parser (. tf text)) :textfield tf))

(defn char->token-index 
  "Returns the token index of the token at char-idx, or nil. "
  [parser char-idx]
  (let [token-idx (binary-search (parser :tokens)
				 (fn [t]
				   (<= (t :next-index) char-idx)))]
    (when token-idx ;; might be nil
      (if (>= char-idx (get-in parser [:tokens token-idx :next-index])) ;; if we're outside the token's range
    	(and (parser :done) ;; char might not be parsed yet in which case we return nil,
    	     token-idx) ;; or we could be in an unparsable end-of-string section, so we return the last token's idx.
    	token-idx))))

(defn content-changed? 
  "Returns true if the textfield's content has been updated since the last call to parse-and-highlight-next!."
  [tfp]
  (not (= (tfp :text) (. (tfp :textfield) text))))

(defn- update-bracket-pairs [bps cutoff-token-idx]
  (let [cutoff (binary-search bps (fn [p] (< (p :r) cutoff-token-idx)))]
    (if cutoff
      (subvec bps 0 cutoff)
      [])))

(defn update-tfp
  "Returns an up-to-date parser (in case the textfield's content has changed)."
  [tfp]
  (if (content-changed? tfp)
    (let [cpl (common-prefix-length (. (tfp :textfield) text) (tfp :text))
	  last-good-token-idx (dec (char->token-index tfp cpl))]
      #_ (psymacs/clear-mini-buffer!)
      #_ (prn "changed - cpl, token-idx:" cpl last-good-token-idx)
      #_ (prn "old tfp:" tfp)
      (if (and last-good-token-idx
	       (> last-good-token-idx 0))
	(merge tfp
	       {:tokens (subvec (tfp :tokens) 0 last-good-token-idx)
		:bracket-pairs (update-bracket-pairs (tfp :bracket-pairs) last-good-token-idx)
		;; TODO: update lbracket-indices
		:text (. (tfp :textfield) text)
		:done false})
	(textfield-parser (tfp :textfield))))
    tfp))

(defn parse-next [parser]
  "Parses the next token, returns updated parser."
  (if (parser :done)
    parser
    (let [token (parse (parser :text) (parse-index parser))]
      (if token
	(merge parser
	       {:tokens 
		(conj (parser :tokens) (assoc token :prev-lbracket ;; save prev-labracket in token
					      (first (parser :lbracket-indices))))

		:lbracket-indices
		(cond (= (token :type) :lbracket)
		      (cons (count (parser :tokens)) (parser :lbracket-indices))
		      
		      (= (token :type) :rbracket)
		      (rest (parser :lbracket-indices))

		      :else
		      (parser :lbracket-indices))

		:bracket-pairs
		(if (and (= (token :type) :rbracket) ;; if we're at an rbracket,
			 (seq (parser :lbracket-indices))) ;; and an open lbracket exists -
		  ;; insert their indices into the bracket-pairs vector
		  (conj (parser :bracket-pairs) 
			{:l (first (parser :lbracket-indices))
			 :r (count (parser :tokens))})
		  (parser :bracket-pairs))})
	(assoc parser :done true)))))

(defn parse-all [parser]
  (if (parser :done)
    parser
    (recur (parse-next parser))))

(defn highlight-last! [tfp]
  "Highlights the last parsed token."
  (let [token (last (tfp :tokens))]
    (when token
      (. (tfp :textfield) (setTextFormat (formats (token :type))
					 (token :index)
					 (token :next-index))))))

(defn parse-and-highlight-next! 
  "Returns a new parser state."
  [tfp]
    (let [tfp (parse-next (update-tfp tfp))]
      (if (not (tfp :done))
	(highlight-last! tfp))
      tfp))

;; testing

(def tf nil)
(def tfp nil)

(defn test-tfp []
  (def tf (new flash.text.TextField))
  (def tfp (textfield-parser tf))
  (set! (. tf width) 300)
  (set! (. tf height) 300)
  (set! (. tf x) 500)
  (set! (. tf y) 100)
  (set! (. tf background) true)
  (set! (. tf backgroundColor) 0xeeeeee)
  (set! (. tf multiline) true)
  (set! (. tf type) "input")
  (set! (. tf defaultTextFormat) (new flash.text.TextFormat "Courier New", 13, 0x000000))
  
  (. *stage* (addEventListener "enterFrame" 
                               (fn [_] 
                                 (def tfp (parse-and-highlight-next! tfp))
                                 (psymacs/clear-mini-buffer!)
				 #_ (prn (char->token-index tfp (. tf caretIndex)))
                                 (prn "tfp:" tfp))))
  (. *stage* (addChild tf)))

(test-tfp)
