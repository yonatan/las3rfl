;; TODO: seperate files, compiler, etc...

(las3r.core/in-ns 'psymacs.utils)
(las3r.core/refer 'las3r.core :exclude '(run-tests))

(def #^{:private true} log-div (. Math (log 2)))
(defmacro #^{:private true} log2 [x] `(/ (. Math (log ~x)) log-div))

(defn get-def
  "flash.utils.getDefinitionByName"
  [name]
  (. com.las3r.runtime.RT (objectForName name)))

(defn vlast 
  "Returns the last element of a vector. Fast."
  [v]
  (when (seq v)
    (v (dec (count v)))))

(defmacro mset! 
  "Sets multiple object properties. Returns the object."
  [obj name-vals]
  (let [sym (gensym)]
    (loop [nv name-vals
           acc '()]
      (if (seq nv)
        (recur (rrest nv) (cons `(set! (. ~sym ~(first nv)) ~(second nv)) acc))
        `(let [~sym ~obj]
           ~@(reverse acc)
           ~sym)))))

(def get-timer (get-def "flash.utils.getTimer"))

(defn sanitize 
  "Sanitize a string - replace tabs w/spaces, newlines with \\n."
  [s]
  (. (. s (replace #"(\r\n|\r)"g "\n")) (replace #"\t"g " ")))

(defn clipped-caret-idx 
  "Returns caret index or index of last char if caret is at end-of-string."
  [tf]
  (min (. tf caretIndex) (max 0 (dec (. tf length)))))

(defn get-line-index-of-char
  "Saner version of TextField::getLineIndexOfChar. Returns nil on failure."
  [tf char-idx]
  (let [tf-len (. tf length)]
    (when (<= 0 char-idx tf-len)
      (cond (zero? char-idx)
            0

            (= char-idx tf-len)
            (let [last-idx (dec char-idx)]
              (+ (. tf (getLineIndexOfChar last-idx))
                 (if (= "\r" (. (. tf text) (charAt last-idx))) 1 0)))

            :else
            (. tf (getLineIndexOfChar char-idx))))))

(defn common-prefix-length [s1 s2]
  (let [min-length (min (count s1) (count s2))]
    (min (loop [step (. Math (pow 2 (. Math (floor (log2 min-length)))))
                l 0]
           (if (< l min-length)
             (if (= (. s1 (substr 0 (+ l step))) (. s2 (substr 0 (+ l step))))
               (recur step (+ l step))
               (if (= step 1)
                 l
                 (recur (bit-shr step 1) l)))
             l))
         min-length)))

(defn binary-search
  "Takes data (should be a sorted vector), and an under-value? predicate function. Returns the index of the match or nil."
  [data under-value?]
  (if (seq data) ;; skip if vector is empty
    (loop [lo 0
           hi (dec (count data))]
      (if (< lo hi)
        (let [mid (+ lo (bit-shr (- hi lo) 1))]
          (if (under-value? (nth data mid))
            (recur (inc mid) hi)
            (recur lo mid)))
        (and (not (under-value? (nth data lo))) lo)))))

(def *char-width* 8)
(def *char-height* 16)

(defn measure-font!
  "Sets char width and height for char-xy fn."
  [tf]
  (let [tmp (new flash.text.TextField)]
    (mset! tmp [embedFonts (. tf embedFonts)
                multiline true
                antiAliasType (. tf antiAliasType)
                autoSize "left"
                defaultTextFormat (. tf defaultTextFormat)])
    (let [extra-x (. tmp width)
          extra-y (. tmp height)
          s (str (apply str (take 1000 (repeat "M")))
                 (apply str (take 999 (repeat "\nM"))))] ;; 1000x1000 chars
      (set! (. tmp text) s)

      (def *char-width* (/ (- (. tmp width) extra-x) 1000))
      (def *char-height* (/ (- (. tmp height) extra-y) 1000)))))

(defn char-xy
  "Returns the [x y] coordinates of the char at the specified index. Compensates for textfield scrolling."
  [tf idx]
  (let [char-row (. tf (getLineIndexOfChar idx))
        line-offset (. tf (getLineOffset char-row))
        char-col (- idx line-offset)]
    [(+ 2 (- (* *char-width* char-col) (. tf scrollH)))
     (+ 2 (* *char-height* (- char-row (dec (. tf scrollV)))))]))

(def #^{:private true} overlay-rect (new flash.geom.Rectangle))

(defn hide-overlay!
  "Hides overlay sprite."
  [buffer]
  (set! (. (buffer :overlay) visible) false))

(defn position-overlay!
  "Positions overlay sprite on top of textfield and applies a scrollRect."
  [buffer]
  (let [overlay (buffer :overlay)
        tf ((buffer :parser) :textfield)]
    (mset! overlay [x (. tf x)
                    y (. tf y)
                    visible true])

    (set! (. overlay-rect width) (. tf width))
    (set! (. overlay-rect height) (. tf height))
    (set! (. overlay scrollRect) overlay-rect)))

(defn matching-bracket
  "Returns c's matching bracket or nil."
  [c]
  (get {"(" ")", ")" "(", "[" "]", "]" "[", "{" "}", "}" "{"} c))

(defn matching-brackets? [x y]
  (= (matching-bracket x) y))

;; mutator shortcuts
(defmacro assoc! [map-name & kvs]
  `(def ~map-name (assoc ~map-name ~@kvs)))

(defmacro dissoc! [map-name & ks]
  `(def ~map-name (dissoc ~map-name ~@ks)))


(defn run-tests []
  ;; common-prefix-length tests
  (assert-true (= (common-prefix-length "Hello World", "Hello World") 11))
  (assert-true (= (common-prefix-length "Hello World", "Hello! World") 5))
  (assert-true (= (common-prefix-length "Hello World", "HelPIYOrld") 3))
  (assert-true (= (common-prefix-length "a", "aB") 1))
  (assert-true (= (common-prefix-length "aBC", "aBCD") 3))
  (assert-true (= (common-prefix-length "Ba", "a") 0))
  (assert-true (= (common-prefix-length "aBC", "DaBC") 0))
  (assert-true (= (common-prefix-length "aXbXc", "aXc") 2))
  (assert-true (= (common-prefix-length "aaaXccc", "aaaXbbbXccc") 4)))

;; Constants

(las3r.core/in-ns 'psymacs.config)
(las3r.core/refer 'las3r.core :exclude '(run-tests))

;; formats make the textfield slower, so use default format as much
;; as possible.

(let [default (new flash.text.TextFormat nil nil 0x000000)]
  (def formats
       {:other       default ;; default token format
        :whitespace  default ;(new flash.text.TextFormat nil nil 0xa0a0a0 false) ;; used on whitespace (and commas)
        :regex       (new flash.text.TextFormat nil nil 0x00aa22)
        :string      (new flash.text.TextFormat nil nil 0xaa8800)
        :unmatched   (new flash.text.TextFormat nil nil 0xff0000)
        :char        (new flash.text.TextFormat nil nil 0xccaa44)
        :comment     (new flash.text.TextFormat nil nil 0xcc2200)
        :lbracket    default ;(new flash.text.TextFormat nil nil 0x005577 true)
        :rbracket    default ;(new flash.text.TextFormat nil nil 0x005577 true)
        :keyword     (new flash.text.TextFormat nil nil 0x008888)
        :int         (new flash.text.TextFormat nil nil 0x440088)
        :float       (new flash.text.TextFormat nil nil 0x8800cc)
        :ratio       (new flash.text.TextFormat nil nil 0xcc00ff)}))

(def *bracket-match-color* 0xAAAAAA)
(def *bracket-mismatch-color* 0xFF0000)
(def *output-cmd-color* 0x808080)
(def *output-color* 0x000000)

;; This is a parser/highlighter for las3r syntax.

;; Since paring a large string can be slow, the parser is designed to
;; work on a token-by-token basis. The parse-next function takes a
;; parser-state, parses a single token, and returns an updated parser
;; state (which contains a vector of all parsed tokens). It should be
;; called several times per frame, to simulate a background thread.

;; Parser structures (maps) come in two flavors, a string parser and a
;; textfield parser. Textfield parsers are string parsers with a
;; :textfield key linking them to a textfield object.

;; A parser map contains these keys:
;;   :text             - the string being parsed.
;;   :tokens           - a vector of parsed tokens (more details below).
;;   :textfield        - a textfield object (textfield-parsers only).
;;   :done             - set to true when parser is finished.

;; A parsed token (also a map) looks like this:
;;   :type          - token type (keyword).
;;   :string        - the actual content of the token.
;;   :index         - char index of the token in the parser's string.
;;   :open-lbrackets - a list of all *open* lbrackets for the current parse-index.
;;   :bracket-pairs  - a vector of token indices pairs {:l int, :r int}, 
;;                    contains all the matching brackets found so far, 
;;                    ordered by the token index of the closing rbracket.
;;   :next-index    - char index of the next token (might not exist, or be parsed yet).

;; :bracket-pairs exists to speed up paren-matching and
;; context-sensitive help in the editor.

;; In order to fake being fast, when a textfield is changed, the
;; parser will skip the already parsed tokens and start at the changed
;; position (hopefully the cursor -- see update-tfp code). This means
;; we need to do some tricks to detect open strings and regexps, and
;; not just treat them as symbols.

(las3r.core/in-ns 'psymacs.parser)
(las3r.core/refer 'las3r.core :exclude '(run-tests))
(refer 'psymacs.config :exclude '(run-tests))
(refer 'psymacs.utils :exclude '(run-tests))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; big hairy parsing regex
(def #^{:private true}
     parser-regex #"#(\"(?:\\?+.)*?\")[gismx]*|([^\s\(\[\{\}\]\)\";,]+)|([\r\n\s,]+)|([\(\[\{])|([\)\]\}])|(\"(?:\\?+.)*?\")|(;[^\r]*)|\\(newline|tab|space|formfeed|return|u[0-9]+|[0-6]+|.)|(#?\".*)"gms)

;; these map to the big hairy regex matches
(def #^{:private true}
     basic-token-types [:regex :other :whitespace :lbracket :rbracket :string :comment :char :unmatched])

(defn- basic-parse
  "Initial token parser, helper for the parse fn."
  [s idx]
  (set! (. parser-regex lastIndex) idx)
  (let [m (. parser-regex (exec s))]
    (when m
      {:type (loop [m (rest m) t basic-token-types]
               (if (first m) 
                 (first t) 
                 (recur (rest m) (rest t))))
       :string (first m)
       :index idx
       :next-index (. parser-regex lastIndex)})))

(defn- parse
  [s idx]
  (let [token (basic-parse s idx)]
    (when token
      (if (= (token :type) :other) ;; handle numbers and keywords
        (let [reader (. *runtime* lispReader) ;; use LispReader's number matching regexes
              ts (token :string)]
          (assoc token :type
                 (cond (= (first ts) ":") :keyword
                       (re-match (. reader intPat)   ts) :int
                       (re-match (. reader floatPat) ts) :float
                       (re-match (. reader ratioPat) ts) :ratio
                       :else :other)))
        token))))

(defn- parse-index
  "Returns the position of the first unparsed char."
  [parser]
  (if (seq (parser :tokens))
    ((vlast (parser :tokens)) :next-index)
    0))

;; highlighting and textfield connectors

(defn string-parser [s]
  {:text s
   :tokens []})

(defn last-token 
  "Takes parser, returns the last parsed token."
  [p]
  (vlast (p :tokens)))

(defn textfield-parser [tf]
  (assoc (string-parser (. tf text)) :textfield tf))

(defn char->token-index 
  "Returns the token index of the token at char-idx, or nil. "
  [parser char-idx]
  (let [token-idx (binary-search (parser :tokens)
                                 (fn [t]
                                   (<= (t :next-index) char-idx)))]
    (when token-idx ;; might be nil
      (if (>= char-idx (get-in parser [:tokens token-idx :next-index])) ;; if we're outside the token's range
        (and (parser :done) ;; char might not be parsed yet in which case we return nil,
             token-idx) ;; or we could be in an unparsable end-of-string section, so we return the last token's idx.
        token-idx))))

(defn content-changed? 
  "Returns true if the textfield's content has been updated since the last call to parse-and-highlight-next!."
  [tfp]
  (not (= (tfp :text) (. (tfp :textfield) text))))

(defn update-tfp
  "Returns an up-to-date parser (in case the textfield's content has changed)."
  [tfp]
  (if (content-changed? tfp)
    (assoc (let [cpl (common-prefix-length (. (tfp :textfield) text) (tfp :text))]
             (if (> cpl (parse-index tfp))
               tfp
               (let [last-good-token-idx (dec (char->token-index tfp (max 0 (dec cpl))))]
                 (if (and last-good-token-idx
                          (> last-good-token-idx 0))
                   (merge tfp
                          {:tokens (subvec (tfp :tokens) 0 last-good-token-idx)
                           :done false})
                   (textfield-parser (tfp :textfield))))))
      :text (. (tfp :textfield) text))
    tfp))

(defn parse-next
  "Parses the next n (1 by defualt - must be positive) tokens, returns updated parser."
  ([parser]
     (parse-next parser 1))
  ([parser n]
     (if (> n 1)
       (recur (parse-next parser 1) (dec n))
       (if (parser :done)
         parser
         (if-let token (parse (parser :text) (parse-index parser)) ;; get next token
           (let [type (token :type)
                 tokens (parser :tokens)
                 cnt (count tokens)
                 prev (vlast tokens)
                 
                 [p-type p-olbs p-bps] 
                 (if (seq prev)
                   [(prev :type) (prev :open-lbrackets) (prev :bracket-pairs)]
                   [nil '() []])

                 ;; new open-lbrackets list
                 olbs (cond (= p-type :lbracket)
                            (cons (dec cnt) p-olbs)
                            
                            (= p-type :rbracket)
                            (rest p-olbs)
                            
                            :else
                            p-olbs)
                 ;; new bracket-pairs vector
                 bps (if (and (= type :rbracket) (seq olbs))
                       (conj p-bps {:l (first olbs) :r cnt})
                       p-bps)

                 token (assoc token :open-lbrackets olbs :bracket-pairs bps)]
             (assoc parser :tokens (conj tokens token)))
           (assoc parser :done true))))))

(defn parse-all [parser]
  (if (parser :done)
    parser
    (recur (parse-next parser))))

(defn highlight-last!
  "Highlights the last parsed token."
  [tfp]
  (let [token (vlast (tfp :tokens))
	tf (tfp :textfield)]
    (when token
      (. tf (setTextFormat (formats (token :type))
			   (token :index)
			   (min (token :next-index)
				(. tf length)))))))

(defn parse-and-highlight-next! 
  "Returns a new parser state."
  [tfp]
  (let [tfp (parse-next tfp)]
    (if (not (tfp :done))
      (highlight-last! tfp))
    tfp))

;; tfp helpers

(defn token-line 
  "Returns the line number on which the token starts."
  [tfp token]
  (get-line-index-of-char (tfp :textfield) (token :index)))

(defn token-col
  "Returns the column number on which the token starts."
  [tfp token]
  (let [line (token-line tfp token)
        line-start (. (tfp :textfield) (getLineOffset line))]
    (- (token :index) line-start)))

;; testing

;; (defn run-tests []
;;   (let [tf (new flash.text.TextField)
;;      tfp (textfield-parser tf)]

;;     (set! (. tf width) 300)
;;     (set! (. tf height) 300)
;;     (set! (. tf x) 500)
;;     (set! (. tf y) 100)
;;     (set! (. tf background) true)
;;     (set! (. tf backgroundColor) 0xeeeeee)
;;     (set! (. tf multiline) true)
;;     (set! (. tf type) "input")
;;     (set! (. tf defaultTextFormat) (new flash.text.TextFormat "Courier New", 13, 0x000000))

;;     (. *stage* (addEventListener "enterFrame" 
;;                               (fn [_] 
;;                                 (def tfp (parse-and-highlight-next! tfp))
;;                                 #_ (psymacs/clear-mini-buffer!)
;;                                 #_ (prn (char->token-index tfp (. tf caretIndex)))
;;                                 #_ (prn "tfp:" tfp))))
;;     (. *stage* (addChild tf))))

;;(time (parse-all (string-parser (psymacs/editor-string))))


(las3r.core/in-ns 'psymacs.undo)
(las3r.core/refer 'las3r.core :exclude '(run-tests))
(refer 'psymacs.parser :exclude '(run-tests))
(refer 'psymacs.utils :exclude '(run-tests))

(def comparator (new jp.psyark.utils.StringComparator))
(defn delta [old-str new-str]
  (. comparator (compare old-str new-str))
  (let [cpl (. comparator commonPrefixLength)
        csl (. comparator commonSuffixLength)]
    {:common-prefix-length cpl
     :common-suffix-length csl
     :old-content (sanitize (subs old-str cpl (- (count old-str) csl)))}))

;; this sets the number of changes saved, not bytes like in emacs.
;; since undo changes are themselves pushed into the undo stack
;; this means the number of changes that can be backed out is
;; undo-limit/2.
(def undo-limit 1000)

(defn- trim-stack
  "Returns a trimmed undo stack."
  [stack]
  (if (> (count stack) undo-limit)
    (subvec stack (- (count stack) undo-limit))
    stack))

(defn create-undo-point 
  "Returns a buffer with  a new undo point, must be called after the 
textfield is changed and before the parser's :text is updated."
  [buffer]
  (let [tf-text (. ((buffer :parser) :textfield) text)
        parser-text ((buffer :parser) :text)]
    (if (= tf-text parser-text)
      buffer ;; return buffer if no change
      (assoc buffer :undo-stack (trim-stack (conj (buffer :undo-stack) (delta parser-text tf-text)))))))

(defn undo! 
  "Updates texfield and returns a new buffer."
  [buffer]
  (let [{stack :undo-stack depth :undo-depth parser :parser} buffer
        tf (parser :textfield)
        stack-last (dec (count stack))]
    (if (and (seq stack)
             (<= depth stack-last))
      (let [delta (nth stack (- stack-last depth))
            start (delta :common-prefix-length)
            end (- (. tf length) (delta :common-suffix-length))
            old-text (delta :old-content)
            caret-idx (+ start (count old-text))]
        (. tf (replaceText start end old-text))
        (. tf (setSelection caret-idx caret-idx))
        (update-in (create-undo-point (assoc buffer :undo-depth (+ depth 2)))
                   [:parser] update-tfp))
      buffer)))

;;;;;;;;;;;;;;;;;;;

(las3r.core/in-ns 'psymacs.keyboard)
(las3r.core/refer 'las3r.core :exclude '(run-tests))
(refer 'psymacs.undo)

(defn event->keystroke [e]
  "Converts a KEY_DOWN event to a {:code ... :modifiers ...} map."
  (let [modifiers #{}
        modifiers (if (. e ctrlKey) (conj modifiers :ctrl) modifiers)
        modifiers (if (. e altKey) (conj modifiers :alt) modifiers)
        modifiers (if (. e shiftKey) (conj modifiers :shift) modifiers)]
    {:code (. e keyCode) :modifiers modifiers}))

(def *kb-map* {})

(defmacro kb
  "Shortcut for flash.ui.Keyboard constants"
  [const]
  `(. flash.ui.Keyboard ~const))

(defn set-key-handler!
  "Sets a function as the handler for a specific keypress. key can be either a character or a key-code, modifiers are a sequence which can contain :ctrl, :alt and :shift."
  [key modifiers handler]
  (def *kb-map*
       (assoc *kb-map*
         {:code (if (string? key)
                  (. (. key (toUpperCase)) (charCodeAt 0))
                  key)
          :modifiers (into #{} modifiers)}
         handler)))

;;;;;;;;;;;;;;;;;;;

(las3r.core/in-ns 'psymacs.main)
(las3r.core/refer 'las3r.core :exclude '(run-tests))
(refer 'psymacs.config)
(refer 'psymacs.parser :exclude '(run-tests))
(refer 'psymacs.utils :exclude '(run-tests))
(refer 'psymacs.keyboard :exclude '(run-tests))
(refer 'psymacs.undo :exclude '(run-tests))

(defn buffer-string [buffer]
  (. ((buffer :parser) :textfield) text))

(defn buffer-tf 
  "Returns the buffer's textfield"
  [buffer]
  ((buffer :parser) :textfield))

(defn get-bracket-enclosed-tokens-at
  "Returns a vector of all tokens including l/r brackets in the sexp at pos, or nil
on failure. Doesn't check if bracket types match each other."
  [parser pos]
  (when-let token-idx (char->token-index parser pos)
    (let [tokens (parser :tokens)
          token (tokens token-idx)
          bracket-pairs ((vlast tokens) :bracket-pairs)]
      (when (seq (token :open-lbrackets))
        (when-let bp-idx (binary-search bracket-pairs ;; find 1st pair with rbracket after or at pos
                                        (fn [bp] 
                                          (< (bp :r) token-idx)))
          (let [bracket-pairs (subvec bracket-pairs bp-idx)] ;; snip irrelevant bracket pairs
            (when-let bp (some (fn [bp] (when (= (bp :l) (first (token :open-lbrackets))) bp)) bracket-pairs)
              (subvec tokens (bp :l) (inc (bp :r))))))))))

(defn get-coll-at
  "Returns a vector of all tokens including l/r brackets in the collection at pos, or nil
on failure."
  [parser pos]
  (when-let enclosed (get-bracket-enclosed-tokens-at parser pos)
    (when (matching-brackets? ((first enclosed) :string) ((vlast enclosed) :string))
      enclosed)))

(defn get-sexp-at
  "If the token at pos is of an ignorable type, scans (backward or forward, depending on 
dir, which should be inc or dec)  for the 1st good token. Returns a vector containing either
the token at pos, or all tokens including l/r brackets in the collection at pos, or nil on 
failure. Fails on mismatched brackets. By default scans backward ignoring whitespace and
comment tokens."
  ([parser pos]
     (get-sexp-at parser pos [:whitespace :comment] dec))
  ([parser pos ignored-types dir]
     (let [tokens (parser :tokens)
           ignored (into #{} ignored-types)
           tokens-cnt (count tokens)]
       (when-let token-idx (char->token-index parser pos)
         (loop [token-idx token-idx]
           (when (< -1 token-idx tokens-cnt)
             (let [token (tokens token-idx)
                   type (token :type)]
               (if (ignored type)
                 (recur (dir token-idx))
                 (cond (= type :lbracket)
                       (get-coll-at parser (inc (token :index)))

                       (= type :rbracket)
                       (get-coll-at parser (token :index))

                       :else
                       [token])))))))))

(defn highlight-current-sexp! 
  "Draws char highlights on the buffer overlay sprite."
  [buffer]
  (let [parser (buffer :parser)
        tf (parser :textfield)
        pos (clipped-caret-idx tf)
        g (. (buffer :overlay) graphics)]
    (. g (clear))
    (when-let sexp-tokens (get-bracket-enclosed-tokens-at parser pos)
      (let [first-token (first sexp-tokens)
            last-token (vlast sexp-tokens)
            l (first-token :index)
            r (last-token :index)
            color (if (matching-brackets? (first-token :string)
                                          (last-token :string))
                    *bracket-match-color*
                    *bracket-mismatch-color*)
            highlight-char! (fn [idx]
                              (let [[x y] (char-xy tf idx)]
                                (. g (beginFill color 0.5))
                                (. g (drawRect x y *char-width* *char-height*))
                                (. g (endFill))))]
        (highlight-char! l)
        (highlight-char! r)))))

(defn attach-to-textfield-container
  "Returns a psymacs buffer. Container should have a readable textField property."
  [cont]
  (let [overlay (new flash.display.Sprite)
        tf (. cont textField)]
    (. cont (addChild overlay))
    {:undo-stack []
     :undo-depth 0
     :container cont
     :overlay overlay
     :parser (textfield-parser tf)}))

(def code-pane (new jp.psyark.psycode.core.TextEditUI))
(def help-pane (new com.bit101.components.TextArea))
(def err-pane (new com.bit101.components.TextArea))
(def out-pane (new com.bit101.components.TextArea))
(def parse-progress (new com.bit101.components.ProgressBar))
(def stats (new net.hires.debug.Stats))
(def buffer (assoc (attach-to-textfield-container code-pane)
              :runtime *runtime*))

(defn current-fn-name [buffer]
  (let [caret-idx (. ((buffer :parser) :textfield) caretIndex)
        pos (if (= caret-idx (count (buffer-string buffer))) ;; if we're past the last char
              (max 0 (dec caret-idx)) ;; go one char back
              caret-idx)]
    (when-let token-idx (char->token-index (buffer :parser) pos)
      (let [tokens ((buffer :parser) :tokens)
            token (tokens token-idx)]
        (when-let doc-idx (some (fn [ti] 
                                  (when (= ((tokens ti) :string) "(") 
                                    (inc ti)))
                                (token :open-lbrackets))
          (let [fn-token (tokens doc-idx)]
            (when (= (fn-token :type) :other)
              (let [fn-name (fn-token :string)]
                (str fn-name)))))))))

(defn print-help
  "Like print-doc, with different formatting."
  [v]
  (println (str (ns-name (get ^v :ns)) "/" (get ^v :name) 
                (if (get ^v :macro) " - Macro" "")))
  (prn (get ^v :arglists))
  (println " " (get ^v :doc)))

;; TODO: search all namespaces?
(defn context-doc [buffer]
  "Shows the enclosing function's documentation in the minibuffer, searches in current *ns* and 'las3r.core."
  []
  (let [tf (. help-pane textField)]
    (set! (. tf text) "")
    (let [name (current-fn-name buffer)]
      (when name
        (try (let [v (or (find-var (symbol (ns-name *ns*) name))
                         (find-var (symbol 'las3r.core name)))
                   arglists ((meta v) :arglists)]
               (binding [*out* (new com.las3r.io.OutputStream (. tf appendText))]
                 (print-help v)))
             (catch Error e nil))))))

(defn update-layout! [& _]
  (let [pbh (. parse-progress height)
        w (. *stage* stageWidth)
        h (- (. *stage* stageHeight) pbh)
        cw (* w 3/4)   ;; code pane width
        ch (* h 4/5)]  ;; code pane height
    (mset! parse-progress [y h width w])
    (set! (. stats x) (- w (. stats width)))

    (mset! code-pane [x 0  y 0       width cw       height ch])
    (mset! help-pane [x 0  y ch      width cw       height (- h ch)])
    (mset! out-pane  [x cw y 0       width (- w cw) height (/ h 2)])
    (mset! err-pane  [x cw y (/ h 2) width (- w cw) height (/ h 2)]))
  (position-overlay! buffer))

(defmacro repeat-until
  "Executes body repeatedly (for side-effects) until condition is met."
  [condition & body]
  `(loop []
     (when-not ~condition
       ~@body
       (recur))))

(def #^{:private true} *prev-scrollv* nil)
(def #^{:private true} *prev-scrollh* nil)
(def #^{:private true} *prev-position* nil)
(def #^{:private true} *ui-needs-update* false)
(def #^{:private true} *last-action-time* 0)

(def *parser-time-limit* (/ 1000 (. *stage* frameRate)))
(def *idle-time* 200)

;; textfield change event dispatchers

(def #^{:private true} ignore-change-events false)

(defn dispatch-change-event [buffer]
  (. ((buffer :parser) :textfield) (dispatchEvent (new flash.events.Event "change" true))))

(defn dispatch-ignorable-change-event [buffer]
  (def #^{:private true} ignore-change-events true)
  (. ((buffer :parser) :textfield) (dispatchEvent (new flash.events.Event "change" true)))
  (def #^{:private true} ignore-change-events false))

(def #^{:private true} prevent-next-input false)

(def changed? false)

;; in principle this should also trigger a full buffer highlight invalidation, 
;; since pasting identical text will remove the formatting and won't be 
;; noticed by update-tfp. but it's not worth the cpu cost imo.
(defn- change-handler [& _]
  (when-not ignore-change-events
    (def changed? true)
    ;; sanitize (cleanup tabs and CRLFs)
    ;; don't touch anything before the 1st bad char, text might already be highlighted
    (let [text (buffer-string buffer)
          first-crlf (. text (indexOf "\r\n"))
          first-tab (. text (indexOf "\t"))]
      (when (or (pos? first-crlf) (pos? first-tab)) ;; if bad chars found
        (let [bad-idx ((if (and (pos? first-crlf) (pos? first-tab))
                         min
                         max) first-crlf first-tab) ;; first bad char idx
              bad-str (subs text bad-idx)
              good-str (sanitize bad-str)]
          (. ((buffer :parser) :textfield) (replaceText bad-idx (count text) good-str)))))
    ;; update parser
    (def buffer (assoc (create-undo-point buffer) :undo-depth 0))
    (assoc! buffer :parser (update-tfp (buffer :parser)))))

(defn- frame-handler [_]
  ;; key-down-handler will set this on non-printables too, so we disable it on each frame.
  (def #^{:private true} prevent-next-input false)

  (let [tf ((buffer :parser) :textfield)
        moved? (not= (. tf caretIndex) *prev-position*)
        scrolled? (not (and (= (. tf scrollV) *prev-scrollv*)
                            (= (. tf scrollH) *prev-scrollh*)))
        time (get-timer)
        busy? (< (- time *last-action-time*) *idle-time*)]
    (when-not busy?
      (when-not ((buffer :parser) :done)
        (let [limit (+ time *parser-time-limit*)]
          (repeat-until (or (> (get-timer) limit)
                            ((buffer :parser) :done))
                        (assoc! buffer :parser (parse-and-highlight-next! (buffer :parser)))))

        (when (seq ((buffer :parser) :tokens))
          (let [buffer-length (. tf length)]
            (mset! parse-progress [maximum buffer-length
                                   value (if ((buffer :parser) :done)
                                           buffer-length
                                           ((vlast ((buffer :parser) :tokens)) :next-index))]))))
      (when *ui-needs-update*
        (def #^{:private true} *ui-needs-update* false)
        (position-overlay! buffer)
        (highlight-current-sexp! buffer)
        (context-doc buffer)))

    (when (or changed? moved? scrolled?)
      (def changed? false)
      (def #^{:private true} *last-action-time* time)
      (def #^{:private true} *ui-needs-update* true)
      (hide-overlay! buffer)

      (def #^{:private true} *prev-scrollh* (. tf scrollH))
      (def #^{:private true} *prev-scrollv* (. tf scrollV))
      (def #^{:private true} *prev-position* (. tf caretIndex)))))

;; key handler

(let [undo-keystroke {:code (. "Z" (charCodeAt 0)) :modifiers #{:ctrl}}]
  (defn key-down-handler [event]
    (let [keystroke (event->keystroke event)]
      (if (= keystroke undo-keystroke)
        (do
          (def buffer (undo! buffer))
                                        ;(def changed? true)
          (def #^{:private true} prevent-next-input true)
          (. event (preventDefault))
          (dispatch-ignorable-change-event buffer))
        (if-let cmd (*kb-map* keystroke)
          (do
            (let [orig-text (buffer-string buffer)]
              (def buffer (cmd buffer))
              (def #^{:private true} prevent-next-input true)
              (. event (preventDefault))
              (when-not (= orig-text (buffer-string buffer))
                (dispatch-change-event buffer))))
          (assoc! buffer :undo-depth 0))))))

(defn text-input-handler [event]
  (when prevent-next-input
    ;; done in enterFrame instead - (def #^{:private true} prevent-next-input false)
    (. event (preventDefault))))

;; editor commands ;;;;;;;;;;;;

(def *commands* {})

(defn set-command! [name command]
  (def *commands*
       (assoc *commands* name command)))

(defmacro def-command [name arg-map & body]
  "Defines an editor command (and a function of the same name)."
  `(do (defn ~name 
         ~(apply str (arg-map :doc)) ;; generate docstring from str/symbol vector -- TODO: doc viewer
         [~'buffer]
         (let [orig-text# (buffer-string ~'buffer)]
           (let [~'parser (~'buffer :parser)
                 {~'tf :textfield ~'tokens :tokens} ~'parser]
             ~@body)
           (when-not (= orig-text# (buffer-string ~'buffer)) ;; if textfield content has changed
             (dispatch-change-event ~'buffer))
           (assoc ~'buffer :undo-depth 0))) ;; return buffer and set undo depth to 0
       (set-key-handler! ~(arg-map :key) ~(arg-map :modifiers) ~name)
       (set-command! (quote ~name) 
                     (assoc (dissoc ~arg-map :key :modifiers) 
                       :fn ~name))))


(defn- custom-indent 
  "Returns custom indentation for symbol or nil."
  [symbol-string]
  (when (or (contains? #{"assoc" "binding" "catch" "comment" "defmulti" "def" "defmacro" "defn" "defstruct" "doseq" "dotimes" "doto" "fn" "for" "implement" "let" "loop" "proxy" "struct-map"}
                       symbol-string)
            (contains? #{"when" "with" "def" "if" "defn" "def" "let"}
                       (second (re-match #"([^-]*)" symbol-string))))
    2))

(defn indent-line!
  "Indents a line (caret line by default), returns a new buffer."
  ([buffer]
     (indent-line! buffer (let [tf ((buffer :parser) :textfield)]
                            (get-line-index-of-char tf (. tf caretIndex)))))
  ([buffer line]
     (let [tf ((buffer :parser) :textfield)
           ;; indenting the last, empty line is a special case...
           on-last-empty-line? (and (= (. tf numLines) (inc line))
                                    (empty? (. tf (getLineText line)))
                                    ((buffer :parser) :done))
           on-caret-line? (= line (get-line-index-of-char tf (. tf caretIndex)))
           buffer (if on-last-empty-line?
                    (do (. tf (appendText " "))
                        (assoc buffer :parser (parse-next (update-tfp (buffer :parser)) 10)))
                    buffer)
           parser (buffer :parser)
           tokens (parser :tokens)
           line-offset (. tf (getLineOffset line))
           line-text (. tf (getLineText line))]
       ;; token refers to the 1st token on the line to be indented
       (when-let token-idx (char->token-index parser line-offset)
         (let [token (tokens token-idx)
               token-start-line (get-line-index-of-char tf (token :index))]
           ;; open-bracket is the first open bracket before the token's line
           (if-let open-bracket-idx (first (filter (fn [idx] (not= (token-line parser (tokens idx)) line))
                                                   (token :open-lbrackets)))
             (let [open-bracket (tokens open-bracket-idx)
                   bracket (open-bracket :string)
                   open-bracket-col (token-col parser open-bracket)
                   open-bracket-line (token-line parser open-bracket)
                   indentation (or (when (= bracket "(")
                                     (when-let sexp-1 (get-sexp-at parser (open-bracket :next-index)
                                                                   [:comment :whitespace] inc)
                                       (or (when-let x (custom-indent ((first sexp-1) :string))
                                             (+ open-bracket-col x))
                                           (when (= open-bracket-line (token-line parser (vlast sexp-1)))
                                             (when-let sexp-2 (get-sexp-at parser (inc ((vlast sexp-1) :next-index))
                                                                           [:comment :whitespace] inc)
                                               (when (= open-bracket-line (token-line parser (first sexp-2)))
                                                 (token-col parser (first sexp-2))))))))
                                   (inc open-bracket-col))
                   chars-to-replace (count (first (re-match #" *" line-text))) ;; number of old spaces
                   spaces (apply str (take indentation (repeat " ")))]
               (let [idx (max line-offset
                              (+ (. tf caretIndex)
                                 (- indentation chars-to-replace) ;; calculate new caret index
                                 (if on-last-empty-line? 1 0)))] ;; compensate for char added to last line
                 (. tf (replaceText line-offset 
                                    (+ line-offset chars-to-replace)
                                    spaces))
                 (when on-caret-line? ;; do we need to move the caret?
                   (. tf (setSelection idx idx)))))
             (if on-last-empty-line? ;; if we added an extra space
               (let [len (. tf length)]  ;; remove it
                 (. tf (replaceText (dec len) len ""))))))))
     buffer))

(def-command indent-current-line
  {:doc ["Auto-indent the current line."]
   :key (kb TAB)
   :tags #{:indentation}}
  (indent-line! buffer))

(def-command move-end-of-line
  {:doc ["Moves the caret to the end of the current line."]
   :key "e"
   :modifiers [:ctrl]
   :tags #{:movement}}
  (let [eol (. (. tf text) (indexOf "\r" (. tf caretIndex)))
        eol (if (= eol -1) (. tf length) eol)]
    (. tf (setSelection eol eol))))

(defn insert 
  "Inserts a string into the buffer's textfield at caret position."
  [buffer s]
  (let [tf (buffer-tf buffer)
        idx (. tf caretIndex)]
    (. tf (replaceText idx idx s))))

(def-command indent-for-ret-command
  {:doc ["Insert a newline and indent."]
   :key (kb ENTER)
   :tags #{:indentation}}
  (insert buffer "\n")
  (let [idx (inc (. tf caretIndex))
        new-buffer (assoc buffer :parser (parse-next (update-tfp (buffer :parser)) 10))]
    (. tf (setSelection idx idx))
    (indent-line! new-buffer)))

(defn- eval-and-print [rt s]
  (let [tf (. out-pane textField)
        fmt (new flash.text.TextFormat)
        set-fmt! (fn [c]
                   (set! (. fmt color) c)
                   (set! (. tf defaultTextFormat) fmt))]
    (set-fmt! *output-cmd-color*)
    (println (str (. (. rt (currentNS)) name) 
		  (if (not= (. s (indexOf "\r")) -1)
		    "=> \n"
		    "=> ")  
		  s))
    (set-fmt! *output-color*)
    (. rt (evalStr s prn nil prn))))

(def-command eval-current-sexp
  {:doc ["Evaluate the sexp at point and print the result."]
   :key "j"
   :modifiers [:ctrl]
   :tags #{:evaluation :sexps}}
  (let [s (apply str (map :string (get-sexp-at parser (clipped-caret-idx tf))))]
    (eval-and-print (buffer :runtime) s)))

(def-command mark-sexp
  {:doc ["Selects the current sexp."]
   :key "s"
   :modifiers [:ctrl :alt]
   :tags #{:selection :sexps}}
  (when-let sexp (get-sexp-at parser (clipped-caret-idx tf))
    (. tf (setSelection ((first sexp) :index) ((vlast sexp) :next-index)))))

(def-command backward-or-up-sexp
  {:doc "Move backward across one sexp, move up and back if at sexp beginning."
   :key "b"
   :modifiers [:ctrl :alt]
   :tags #{:movement :sexps}}
  (when-let sexp (get-sexp-at parser (max 0 (dec (. tf caretIndex))))
    (let [idx ((first sexp) :index)]
      (. tf (setSelection idx idx)))))

(def-command forward-or-up-sexp
  {:doc "Move forward across one sexp, move up and forward if at sexp end."
   :key "f"
   :modifiers [:ctrl :alt]
   :tags #{:movement :sexps}}
  (when-let sexp (get-sexp-at parser
                              (min (dec (. tf length))
                                   (inc (. tf caretIndex)))
                              [:comment :whitespace]
                              inc)
    (let [idx ((vlast sexp) :next-index)]
      (. tf (setSelection idx idx)))))

(def-command kill-whitespace
  {:doc "Removes whitespace at point."
   :key "w"
   :modifiers [:alt]}
  (when-let idx (char->token-index parser (. tf caretIndex))
    (let [token ((parser :tokens) idx)
          {idx :index} token]
      (when (= (token :type) :whitespace)
        (. tf (replaceText idx (token :next-index) ""))
        (. tf (setSelection idx idx))))))

(defn prn-current-sexp [buffer]
  (prn (apply str (map :string (get-sexp-at (buffer :parser) (clipped-caret-idx ((buffer :parser) :textfield))))))
  buffer)

(defn prn-hello [buffer]
  (prn "hello")
  buffer)

(set-key-handler! "s" [:ctrl] prn-current-sexp)
(set-key-handler! "e" [:ctrl] move-end-of-line)

(defn init []
  (let [tf ((buffer :parser) :textfield)
        make-printer (fn [pane]
                       (fn [s]
                         (let [tf (. pane textField)]
                           (. tf (appendText (sanitize s)))
                           (set! (. tf scrollV) (. tf maxScrollV)))))]
    (doseq obj [code-pane help-pane out-pane err-pane parse-progress stats]
      (. *stage* (addChild obj)))

    (. *stage* (addEventListener "resize" update-layout!))
    (. tf (addEventListener "keyDown" key-down-handler))
    (. tf (addEventListener "textInput" text-input-handler))
    (. tf (addEventListener "change" change-handler))
    (. *stage* (addEventListener "enterFrame" frame-handler))

    ;; show repl on top
    ;; (let [repl (. (get-def "MCompsTest") repl)]
    ;;   (. *stage* (addChild repl))
    ;;   (mset! repl [x (- (. *stage* stageWidth) (. repl width))
    ;;                y (- (. *stage* stageHeight) (. repl height))]))

    ;; setup out and err streams
    (let [editor-class (get-def "MCompsTest")]
      (set! (. editor-class out) (make-printer out-pane))
      (set! (. editor-class err) (make-printer err-pane)))

    (measure-font! tf)
    (update-layout!)

    ;; tmp testing helpers
    (def ctf tf)
    (defn ui [] (prn "stack: " (buffer :undo-stack) "\ndepth: " (buffer :undo-depth)))
    (defn undo [] (def buffer (undo! buffer)))

    ))

(defn deinit [] ; for debugging purposes
  (. *stage* (removeEventListener "resize" update-layout!))
  (. *stage* (removeEventListener "enterFrame" frame-handler)))

(init)

