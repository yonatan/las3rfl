;; TODO: seperate files, compiler, etc...

(las3r.core/in-ns 'psymacs.utils)
(las3r.core/refer 'las3r.core :exclude '(run-tests))

(def #^{:private true} log-div (. Math (log 2)))
(defmacro #^{:private true} log2 [x] `(/ (. Math (log ~x)) log-div))

(defn get-def
  "flash.utils.getDefinitionByName"
  [name]
  (. com.las3r.runtime.RT (objectForName name)))

(defn vlast 
  "Returns the last element of a vector. Fast."
  [v]
  (when (seq v)
    (v (dec (count v)))))

(defmacro mset! 
  "Sets multiple object properties."
  [obj name-vals]
  (loop [nv name-vals
         acc '()]
    (if (seq nv)
      (recur (rrest nv) (cons `(set! (. ~obj ~(first nv)) ~(second nv)) acc))
      `(do ~@(reverse acc)))))

(def get-timer (get-def "flash.utils.getTimer"))

(defn common-prefix-length [s1 s2]
  (let [min-length (min (count s1) (count s2))]
    (min (loop [step (. Math (pow 2 (. Math (floor (log2 min-length)))))
                l 0]
           (if (< l min-length)
             (if (= (. s1 (substr 0 (+ l step))) (. s2 (substr 0 (+ l step))))
               (recur step (+ l step))
               (if (= step 1)
                 l
                 (recur (bit-shr step 1) l)))
             l))
         min-length)))

(defn binary-search
  "Takes data (should be a sorted vector), and an under-value? predicate function. Returns the index of the match or nil."
  [data under-value?]
  (if (seq data) ;; skip if vector is empty
    (loop [lo 0
           hi (dec (count data))]
      (if (< lo hi)
        (let [mid (+ lo (bit-shr (- hi lo) 1))]
          (if (under-value? (nth data mid))
            (recur (inc mid) hi)
            (recur lo mid)))
        (and (not (under-value? (nth data lo))) lo)))))

(def *char-width* 7.8283)
(def *char-height* 16)

(defn measure-font!
  "Sets char width and height for char-xy fn."
  [tf]
  (let [tmp (new flash.text.TextField)]
    (mset! tmp [embedFonts (. tf embedFonts)
    		multiline true
    		antiAliasType (. tf antiAliasType)
    		autoSize "left"
    		defaultTextFormat (. tf defaultTextFormat)])
    (let [extra-x (. tmp width)
    	  extra-y (. tmp height)
    	  s (str (apply str (take 1000 (repeat "M")))
    		 (apply str (take 999 (repeat "\nM"))))] ;; 1000x1000 chars
      (set! (. tmp text) s)

      (def *char-width* (/ (- (. tmp width) extra-x) 1000))
      (def *char-height* (/ (- (. tmp height) extra-y) 1000)))))

(defn char-xy
  "Returns the [x y] coordinates of the char at the specified index. Compensates for textfield scrolling."
  [tf idx]
  (let [char-row (. tf (getLineIndexOfChar idx))
        line-offset (. tf (getLineOffset char-row))
        char-col (- idx line-offset)]
    [(+ 2 (- (* *char-width* char-col) (. tf scrollH)))
     (+ 2 (* *char-height* (- char-row (dec (. tf scrollV)))))]))

(def #^{:private true} overlay-rect (new flash.geom.Rectangle))

(defn position-overlay!
  "Positions overlay sprite on top of textfield and applies a scrollRect."
  [buffer]
  (let [overlay (buffer :overlay)
        tf (buffer :textfield)]
    (set! (. overlay x) (. tf x))
    (set! (. overlay y) (. tf y))

    (set! (. overlay-rect width) (. tf width))
    (set! (. overlay-rect height) (. tf height))
    (set! (. overlay scrollRect) overlay-rect)
    ;; (set! (. overlay scrollRect) (new flash.geom.Rectangle 0 0 (. tf width) (. tf height)))
))

(defn matching-bracket
  "Returns c's matching bracket or nil."
  [c]
  (get {"(" ")", ")" "(", "[" "]", "]" "[", "{" "}", "}" "{"} c))

(defn matching-brackets? [x y]
  (= (matching-bracket x) y))

(defn run-tests []
  ;; common-prefix-length tests
  (assert-true (= (common-prefix-length "Hello World", "Hello World") 11))
  (assert-true (= (common-prefix-length "Hello World", "Hello! World") 5))
  (assert-true (= (common-prefix-length "Hello World", "HelPIYOrld") 3))
  (assert-true (= (common-prefix-length "a", "aB") 1))
  (assert-true (= (common-prefix-length "aBC", "aBCD") 3))
  (assert-true (= (common-prefix-length "Ba", "a") 0))
  (assert-true (= (common-prefix-length "aBC", "DaBC") 0))
  (assert-true (= (common-prefix-length "aXbXc", "aXc") 2))
  (assert-true (= (common-prefix-length "aaaXccc", "aaaXbbbXccc") 4)))



;; This is a parser/highlighter for las3r syntax.

;; Since paring a large string can be slow, the parser is designed to
;; work on a token-by-token basis. The parse-next function takes a
;; parser-state, parses a single token, and returns an updated parser
;; state (which contains a vector of all parsed tokens). It should be
;; called several times per frame, to simulate a background thread.

;; Parser structures (maps) come in two flavors, a string parser and a
;; textfield parser. Textfield parsers are string parsers with a
;; :textfield key linking them to a textfield object.

;; A parser map contains these keys:
;;   :text             - the string being parsed.
;;   :tokens           - a vector of parsed tokens (more details below).
;;   :textfield        - a textfield object (textfield-parsers only).
;;   :done             - set to true when parser is finished.

;; A parsed token (also a map) looks like this:
;;   :type          - token type (keyword).
;;   :string        - the actual content of the token.
;;   :index         - char index of the token in the parser's string.
;;   :open-lbrackets - a list of all *open* lbrackets for the current parse-index.
;;   :bracket-pairs  - a vector of token indices pairs {:l int, :r int}, 
;;                    contains all the matching brackets found so far, 
;;                    ordered by the token index of the closing rbracket.
;;   :next-index    - char index of the next token (might not exist, or be parsed yet).

;; :bracket-pairs exists to speed up paren-matching and
;; context-sensitive help in the editor.

;; In order to fake being fast, when a textfield is changed, the
;; parser will skip the already parsed tokens and start at the changed
;; position (hopefully the cursor -- see update-tfp code). This means
;; we need to do some tricks to detect open strings and regexps, and
;; not just treat them as symbols.

(las3r.core/in-ns 'psymacs.parser)
(las3r.core/refer 'psymacs.utils :exclude '(run-tests))
(las3r.core/refer 'las3r.core :exclude '(run-tests))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; big hairy parsing regex
(def #^{:private true}
     parser-regex #"#(\"(?:\\?+.)*?\")[gismx]*|([^\s\(\[\{\}\]\)\";,]+)|([\r\s,]+)|([\(\[\{])|([\)\]\}])|(\"(?:\\?+.)*?\")|(;[^\r]*)|\\(newline|tab|space|formfeed|return|u[0-9]+|[0-6]+|.)|(#?\".*)"gms)

;; these map to the big hairy regex matches
(def #^{:private true}
     basic-token-types [:regex :other :whitespace :lbracket :rbracket :string :comment :char :unmatched])

(defn- basic-parse
  "Initial token parser, helper for the parse fn."
  [s idx]
  (set! (. parser-regex lastIndex) idx)
  (let [m (. parser-regex (exec s))]
    (when m
      {:type (loop [m (rest m) t basic-token-types]
               (if (first m) 
                 (first t) 
                 (recur (rest m) (rest t))))
       :string (first m)
       :index idx
       :next-index (. parser-regex lastIndex)})))

(defn- parse
  [s idx]
  (let [token (basic-parse s idx)]
    (when token
      (if (= (token :type) :other) ;; handle numbers and keywords
        (let [reader (. *runtime* lispReader) ;; use LispReader's number matching regexes
              ts (token :string)]
          (assoc token :type
                 (cond (= (first ts) ":") :keyword
                       (re-match (. reader intPat)   ts) :int
                       (re-match (. reader floatPat) ts) :float
                       (re-match (. reader ratioPat) ts) :ratio
                       :else :other)))
        token))))

(defn- parse-index
  "Returns the position of the first unparsed char."
  [parser]
  (if (seq (parser :tokens))
    ((vlast (parser :tokens)) :next-index)
    0))

;; highlighting and textfield connectors

(def formats
     {:other       (new flash.text.TextFormat nil nil 0x000000 false) ;; default token format
      :whitespace  (new flash.text.TextFormat nil nil 0xa0a0a0 false) ;; used on whitespace (and commas)
      :regex       (new flash.text.TextFormat nil nil 0x00aa22 false)
      :string      (new flash.text.TextFormat nil nil 0xaa8800 false)
      :unmatched   (new flash.text.TextFormat nil nil 0xff0000 false)
      :char        (new flash.text.TextFormat nil nil 0xccaa44 false)
      :comment     (new flash.text.TextFormat nil nil 0xcc2200 false)
      :lbracket    (new flash.text.TextFormat nil nil 0x005577 false)
      :rbracket    (new flash.text.TextFormat nil nil 0x005577 false)
      :keyword     (new flash.text.TextFormat nil nil 0x008888 false)
      :int         (new flash.text.TextFormat nil nil 0x440088 false)
      :float       (new flash.text.TextFormat nil nil 0x8800cc false)
      :ratio       (new flash.text.TextFormat nil nil 0xcc00ff false)})

(defn string-parser [s]
  {:text s
   :tokens []})

(defn last-token 
  "Takes parser, returns the last parsed token."
  [p]
  (vlast (p :tokens)))

(defn textfield-parser [tf]
  (assoc (string-parser (. tf text)) :textfield tf))

(defn char->token-index 
  "Returns the token index of the token at char-idx, or nil. "
  [parser char-idx]
  (let [token-idx (binary-search (parser :tokens)
                                 (fn [t]
                                   (<= (t :next-index) char-idx)))]
    (when token-idx ;; might be nil
      (if (>= char-idx (get-in parser [:tokens token-idx :next-index])) ;; if we're outside the token's range
        (and (parser :done) ;; char might not be parsed yet in which case we return nil,
             token-idx) ;; or we could be in an unparsable end-of-string section, so we return the last token's idx.
        token-idx))))

(defn content-changed? 
  "Returns true if the textfield's content has been updated since the last call to parse-and-highlight-next!."
  [tfp]
  (not (= (tfp :text) (. (tfp :textfield) text))))

(defn update-tfp
  "Returns an up-to-date parser (in case the textfield's content has changed)."
  [tfp]
  (if (content-changed? tfp)
    ;; (textfield-parser (tfp :textfield)) ;; debug - bypass
    ;; #_
    (let [cpl (common-prefix-length (. (tfp :textfield) text) (tfp :text))]
      (if (> cpl (parse-index tfp))
        tfp
        (let [last-good-token-idx (dec (char->token-index tfp cpl))]
          (if (and last-good-token-idx
                   (> last-good-token-idx 0))
            (merge tfp
                   {:tokens (subvec (tfp :tokens) 0 last-good-token-idx)
                    :text (. (tfp :textfield) text)
                    :done false})
            (textfield-parser (tfp :textfield))))))
    tfp))

(defn parse-next [parser]
  "Parses the next token, returns updated parser."
  (if (parser :done)
    parser
    (if-let token (parse (parser :text) (parse-index parser)) ;; get next token
      (let [type (token :type)
            tokens (parser :tokens)
            cnt (count tokens)
            prev (vlast tokens)
            
            [p-type p-olbs p-bps] 
            (if (seq prev)
              [(prev :type) (prev :open-lbrackets) (prev :bracket-pairs)]
              [nil '() []])

            ;; new open-lbrackets list
            olbs (cond (= p-type :lbracket)
                       (cons (dec cnt) p-olbs)
                       
                       (= p-type :rbracket)
                       (rest p-olbs)
                       
                       :else
                       p-olbs)
            ;; new bracket-pairs vector
            bps (if (and (= type :rbracket) (seq olbs))
                  (conj p-bps {:l (first olbs) :r cnt})
                  p-bps)

            token (assoc token :open-lbrackets olbs :bracket-pairs bps)]
            (assoc parser :tokens (conj tokens token)))
      (assoc parser :done true))))

(defn parse-all [parser]
  (if (parser :done)
    parser
    (recur (parse-next parser))))

(defn highlight-last! [tfp]
  "Highlights the last parsed token."
  (let [token (vlast (tfp :tokens))]
    (when token
      (. (tfp :textfield) (setTextFormat (formats (token :type))
                                         (token :index)
                                         (token :next-index))))))

(defn parse-and-highlight-next! 
  "Returns a new parser state."
  [tfp]
  (let [tfp (parse-next (update-tfp tfp))]
    (if (not (tfp :done))
      (highlight-last! tfp))
    tfp))

;; testing

;; (defn run-tests []
;;   (let [tf (new flash.text.TextField)
;;      tfp (textfield-parser tf)]

;;     (set! (. tf width) 300)
;;     (set! (. tf height) 300)
;;     (set! (. tf x) 500)
;;     (set! (. tf y) 100)
;;     (set! (. tf background) true)
;;     (set! (. tf backgroundColor) 0xeeeeee)
;;     (set! (. tf multiline) true)
;;     (set! (. tf type) "input")
;;     (set! (. tf defaultTextFormat) (new flash.text.TextFormat "Courier New", 13, 0x000000))
    
;;     (. *stage* (addEventListener "enterFrame" 
;;                               (fn [_] 
;;                                 (def tfp (parse-and-highlight-next! tfp))
;;                                 #_ (psymacs/clear-mini-buffer!)
;;                                 #_ (prn (char->token-index tfp (. tf caretIndex)))
;;                                 #_ (prn "tfp:" tfp))))
;;     (. *stage* (addChild tf))))

;;(time (parse-all (string-parser (psymacs/editor-string))))

(las3r.core/in-ns 'psymacs.keyboard)
(las3r.core/refer 'las3r.core :exclude '(run-tests))

(defn event->keystroke [e]
  "Converts a KEY_DOWN event to a {:code ... :modifiers ...} map."
  (let [modifiers #{}
        modifiers (if (. e ctrlKey) (conj modifiers :ctrl) modifiers)
        modifiers (if (. e altKey) (conj modifiers :alt) modifiers)
        modifiers (if (. e shiftKey) (conj modifiers :shift) modifiers)]
    {:code (. e keyCode) :modifiers modifiers}))



;;;;;;;;;;;;;;;;;;;

(las3r.core/in-ns 'psymacs.main)
(las3r.core/refer 'las3r.core :exclude '(run-tests))
(las3r.core/refer 'psymacs.parser :exclude '(run-tests))
(las3r.core/refer 'psymacs.utils :exclude '(run-tests))
(las3r.core/refer 'psymacs.keyboard :exclude '(run-tests))

(def *bracket-match-color* 0xAAAAAA)
(def *bracket-mismatch-color* 0xFF0000)
(def *background-color* 0xEEEEEE)

(defn buffer-string [buffer]
  (. (buffer :textfield) text))

(defn highlight-current-sexp! [buffer]
  (let [pos (. (buffer :textfield) caretIndex)
        g (. (buffer :overlay) graphics)]
    (. g (clear))
    (when-let token-idx (char->token-index (buffer :parser) pos)
      (let [tokens ((buffer :parser) :tokens)
            token (tokens token-idx)
            bracket-pairs ((vlast tokens) :bracket-pairs)]
        (when (seq (token :open-lbrackets))
          (when-let bp-idx (binary-search bracket-pairs ;; find 1st pair with rbracket after or at pos
                                          (fn [bp] 
                                            (< (bp :r) token-idx)))
            (let [bracket-pairs (subvec bracket-pairs bp-idx)] ;; snip irrelevant bracket pairs
              (when-let bp (some (fn [bp] (when (= (bp :l) (first (token :open-lbrackets))) bp)) bracket-pairs)
                (let [tf (buffer :textfield)
                      l ((tokens (bp :l)) :index)
                      r ((tokens (bp :r)) :index)
                      color (if (matching-brackets? ((tokens (bp :l)) :string)
                                                    ((tokens (bp :r)) :string))
                              *bracket-match-color*
                              *bracket-mismatch-color*)
                      highlight-char! (fn [idx]
                                        (let [[x y] (char-xy tf idx)]
                                          (. g (beginFill color 0.5))
                                          (. g (drawRect x y *char-width* *char-height*))
                                          (. g (endFill))))]
                  (highlight-char! l)
                  (highlight-char! r))))))))))


(defn attach-to-textfield-container
  "Returns a psymacs buffer. Container should have a readable textField property."
  [cont]
  (let [overlay (new flash.display.Sprite)
        tf (. cont textField)]
    (. cont (addChild overlay))
    {:textfield tf
     :container cont
     :overlay overlay
     :parser (textfield-parser tf)}))

(def code-pane (new jp.psyark.psycode.core.TextEditUI))
(def help-pane (new com.bit101.components.TextArea))
(def err-pane (new com.bit101.components.TextArea))
(def out-pane (new com.bit101.components.TextArea))
(def parse-progress (new com.bit101.components.ProgressBar))
(def buffer (assoc (attach-to-textfield-container code-pane)
	      :runtime *runtime*))


(defn current-fn-name [buffer]
  (let [caret-idx (. (buffer :textfield) caretIndex)
        pos (if (= caret-idx (count (buffer-string buffer))) ;; if we're past the last char
              (max 0 (dec caret-idx)) ;; go one char back
              caret-idx)]
    (when-let token-idx (char->token-index (buffer :parser) pos)
      (let [tokens ((buffer :parser) :tokens)
            token (tokens token-idx)]
        (when-let doc-idx (some (fn [ti] 
                                  (when (= ((tokens ti) :string) "(") 
                                    (inc ti)))
                                (token :open-lbrackets))
          (let [fn-token (tokens doc-idx)]
            (when (= (fn-token :type) :other)
              (let [fn-name (fn-token :string)]
                (str fn-name)))))))))

(defn print-help
  "Like print-doc, with different formatting."
  [v]
  (println (str (ns-name (get ^v :ns)) "/" (get ^v :name) 
		(if (get ^v :macro) " - Macro" "")))
  (prn (get ^v :arglists))
  (println " " (get ^v :doc)))

;; TODO: search all namespaces?
(defn context-doc [buffer]
  "Shows the enclosing function's documentation in the minibuffer, searches in current *ns* and 'las3r.core."
  []
  (let [tf (. help-pane textField)]
    (set! (. tf text) "")
    (let [name (current-fn-name buffer)]
      (when name
	(try (let [v (or (find-var (symbol (ns-name *ns*) name))
			 (find-var (symbol 'las3r.core name)))
		   arglists ((meta v) :arglists)]
	       (binding [*out* (new com.las3r.io.OutputStream (. tf appendText))]
		 (print-help v)))
	     (catch Error e nil))))))

(defn update-layout! [& _]
  (let [pbh (. parse-progress height)
	w (. *stage* stageWidth)
        h (- (. *stage* stageHeight) pbh)
        cw (* w 3/4)   ;; code pane width
        ch (* h 4/5)]  ;; code pane height
    (mset! parse-progress [y h width w])

    (mset! code-pane [x 0  y 0       width cw       height ch])
    (mset! help-pane [x 0  y ch      width cw       height (- h ch)])
    (mset! out-pane  [x cw y 0       width (- w cw) height (/ h 2)])
    (mset! err-pane  [x cw y (/ h 2) width (- w cw) height (/ h 2)]))
  (position-overlay! buffer))

(defmacro repeat-until
  "Executes body repeatedly (for side-effects) until condition is met."
  [condition & body]
  `(loop []
     (when-not ~condition
       ~@body
       (recur))))

(def #^{:private true} *prev-text* nil)
(def #^{:private true} *prev-scrollv* nil)
(def #^{:private true} *prev-scrollh* nil)
(def #^{:private true} *prev-position* nil)
(def *parser-time-limit* (/ 1000 (. *stage* frameRate)))

(defn- changed? []
  (not= (. (buffer :textfield) text) *prev-text*))

(defn- moved? []
  (not= (. (buffer :textfield) caretIndex) *prev-position*))

(defn- scrolled? []
  (not (and (= (. (buffer :textfield) scrollV) *prev-scrollv*)
	    (= (. (buffer :textfield) scrollH) *prev-scrollh*))))

(defn- frame-handler [_] 
  (when (changed?)
    ;; sanitize
    (set! (. (buffer :textfield) text)
	  (. (. (. (buffer :textfield) text) (replace #"(\r\n|\r)"g "\n")) (replace #"\t"g " ")))
    ;; update parser
    (def buffer (assoc buffer :parser (update-tfp (buffer :parser)))))

  (when-not ((buffer :parser) :done)
    (let [limit (+ (get-timer) *parser-time-limit*)]
      (repeat-until (or (> (get-timer) limit) (> (get-timer) limit)
			((buffer :parser) :done))
		    (def buffer (assoc buffer :parser (parse-and-highlight-next! (buffer :parser))))))

    (let [buffer-length (count (. (buffer :textfield) text))]
      (mset! parse-progress [maximum buffer-length
			     value (if ((buffer :parser) :done)
				     buffer-length
				     ((vlast ((buffer :parser) :tokens)) :next-index))])))

  (when (or (changed?) (moved?) (scrolled?))
    (position-overlay! buffer)
    (highlight-current-sexp! buffer))

  (when (or (changed?) (moved?))
    (context-doc buffer))

  (let [tf (buffer :textfield)]
    (def *prev-scrollh* (. tf scrollH))
    (def *prev-scrollv* (. tf scrollV))
    (def *prev-text* (. tf text))
    (def *prev-position* (. tf caretIndex))))

(defn init []
  (doseq obj [code-pane help-pane out-pane err-pane parse-progress]
    (. *stage* (addChild obj)))
  (. *stage* (addEventListener "resize" update-layout!))
  (. *stage* (addEventListener "enterFrame" frame-handler))

  (measure-font! (buffer :textfield))
  (update-layout!)

  (def ctf (buffer :textfield))

  ;; (def stdout (new com.las3r.io.OutputStream (. (. out-pane textField) appendText)))
  ;; (def lns (. *runtime* LAS3R_NAMESPACE))
  ;; (. com.las3r.runtime.Var (internWithRoot lns '*out* stdout))
  

)

(defn deinit [] ; for debugging purposes
  (. *stage* (removeEventListener "resize" update-layout!))
  (. *stage* (removeEventListener "enterFrame" frame-handler)))
  
  

;; (defn run-tests []
;;   (def teui (new jp.psyark.psycode.core.TextEditUI))

;;   (def buff (attach-to-textfield-container teui))

;;   (set! (. teui width) 300)
;;   (set! (. teui height) 300)
;;   (set! (. teui x) 500)
;;   (set! (. teui y) 100)
;;   ;(set! (. (buff :container) scrollRect) (new flash.geom.Rectangle 0 0 300 300))
  
;;   (. *stage* (addEventListener "enterFrame" frame-handler))
;;   (. *stage* (addChild (buff :container))))
