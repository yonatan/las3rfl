;; TODO: seperate files, compiler, etc...

(las3r.core/in-ns 'psymacs.utils)
(las3r.core/refer 'las3r.core :exclude '(run-tests))

;; debug

(defn prn-props [obj]
  (prn 'obj obj)
  (doseq p (get-property-names obj)
    (prn p (get-property obj p))))

(def #^{:private true} log-div (. Math (log 2)))
(defmacro #^{:private true} log2 [x] `(/ (. Math (log ~x)) log-div))

(def *platform* (first (. (. flash.system.Capabilities version) (split " "))))

(defn get-def
  "flash.utils.getDefinitionByName"
  [name]
  (. com.las3r.runtime.RT (objectForName name)))

(defn vlast 
  "Returns the last element of a vector. Fast."
  [v]
  (when (seq v)
    (v (dec (count v)))))

(defmacro mset! 
  "Sets multiple object properties. Returns the object."
  [obj name-vals]
  (let [sym (gensym)]
    (loop [nv name-vals
           acc '()]
      (if (seq nv)
        (recur (rrest nv) (cons `(set! (. ~sym ~(first nv)) ~(second nv)) acc))
        `(let [~sym ~obj]
           ~@(reverse acc)
           ~sym)))))

(def get-timer (get-def "flash.utils.getTimer"))

(def Base64Encoder (get-def "Base64Encoder"))

(defn sanitize 
  "Sanitize a string - replace tabs w/spaces, newlines with \\n."
  [s]
  (. (. s (replace #"(\r\n|\r)"g "\n")) (replace #"\t"g " ")))

(defn clipped-caret-idx 
  "Returns caret index or index of last char if caret is at end-of-string."
  [tf]
  (min (. tf caretIndex) (max 0 (dec (. tf length)))))

(defn get-line-index-of-char
  "Saner version of TextField::getLineIndexOfChar. Returns nil on failure."
  [tf char-idx]
  (let [tf-len (. tf length)]
    (when (<= 0 char-idx tf-len)
      (cond (zero? char-idx)
            0

            (= char-idx tf-len)
            (let [last-idx (dec char-idx)]
              (+ (. tf (getLineIndexOfChar last-idx))
                 (if (= "\r" (. (. tf text) (charAt last-idx))) 1 0)))

            :else
            (. tf (getLineIndexOfChar char-idx))))))

(defn common-prefix-length [s1 s2]
  (let [min-length (min (count s1) (count s2))]
    (min (loop [step (. Math (pow 2 (. Math (floor (log2 min-length)))))
                l 0]
           (if (< l min-length)
             (if (= (. s1 (substr 0 (+ l step))) (. s2 (substr 0 (+ l step))))
               (recur step (+ l step))
               (if (= step 1)
                 l
                 (recur (bit-shr step 1) l)))
             l))
         min-length)))

(defn binary-search
  "Takes data (should be a sorted vector), and an under-value? predicate function. Returns the index of the match or nil."
  [data under-value?]
  (if (seq data) ;; skip if vector is empty
    (loop [lo 0
           hi (dec (count data))]
      (if (< lo hi)
        (let [mid (+ lo (bit-shr (- hi lo) 1))]
          (if (under-value? (nth data mid))
            (recur (inc mid) hi)
            (recur lo mid)))
        (and (not (under-value? (nth data lo))) lo)))))

(def *char-width* 8)
(def *char-height* 16)

(defn measure-font!
  "Sets char width and height for char-xy fn."
  [tf]
  (let [tmp (new flash.text.TextField)]
    (mset! tmp [embedFonts (. tf embedFonts)
                multiline true
                antiAliasType (. tf antiAliasType)
                autoSize "left"
                defaultTextFormat (. tf defaultTextFormat)])
    (let [extra-x (. tmp width)
          extra-y (. tmp height)
          s (str (apply str (take 1000 (repeat "M")))
                 (apply str (take 999 (repeat "\nM"))))] ;; 1000x1000 chars
      (set! (. tmp text) s)

      (def *char-width* (/ (- (. tmp width) extra-x) 1000))
      (def *char-height* (/ (- (. tmp height) extra-y) 1000)))))

(defn char-xy
  "Returns the [x y] coordinates of the char at the specified index. Compensates for textfield scrolling."
  [tf idx]
  (let [char-row (. tf (getLineIndexOfChar idx))
        line-offset (. tf (getLineOffset char-row))
        char-col (- idx line-offset)]
    [(+ 2 (- (* *char-width* char-col) (. tf scrollH)))
     (+ 2 (* *char-height* (- char-row (dec (. tf scrollV)))))]))

(def #^{:private true} overlay-rect (new flash.geom.Rectangle))

(defn hide-overlay!
  "Hides overlay sprite."
  [buffer]
  (set! (. (buffer :overlay) visible) false))

(defn position-overlay!
  "Positions overlay sprite on top of textfield and applies a scrollRect."
  [buffer]
  (let [overlay (buffer :overlay)
        tf ((buffer :parser) :textfield)]
    (mset! overlay [x (. tf x)
                    y (. tf y)
                    visible true])

    (set! (. overlay-rect width) (. tf width))
    (set! (. overlay-rect height) (. tf height))
    (set! (. overlay scrollRect) overlay-rect)))

(defn matching-bracket
  "Returns c's matching bracket or nil."
  [c]
  (get {"(" ")", ")" "(", "[" "]", "]" "[", "{" "}", "}" "{"} c))

(defn matching-brackets? [x y]
  (= (matching-bracket x) y))

;; mutator shortcuts
(defmacro assoc! [map-name & kvs]
  `(def ~map-name (assoc ~map-name ~@kvs)))

(defmacro dissoc! [map-name & ks]
  `(def ~map-name (dissoc ~map-name ~@ks)))

;; event helpers

(defmacro on-next
  "Create a one-time event listener. The symbol event will be bound to the event inside body. Returns a cancel-thunk which can be called to remove the handler before it has fired."
  [dispatcher event & handler-body]
  `(let [dispatcher# ~dispatcher
	 event# ~event
	 handler# (fn tmp# [~'event]
		    ~@handler-body
		    (. dispatcher# (removeEventListener event# tmp#)))]
     (. dispatcher# (addEventListener event# handler#))
     (fn [] (. dispatcher# (removeEventListener event# handler#)))))

(defn run-tests []
  ;; common-prefix-length tests
  (assert-true (= (common-prefix-length "Hello World", "Hello World") 11))
  (assert-true (= (common-prefix-length "Hello World", "Hello! World") 5))
  (assert-true (= (common-prefix-length "Hello World", "HelPIYOrld") 3))
  (assert-true (= (common-prefix-length "a", "aB") 1))
  (assert-true (= (common-prefix-length "aBC", "aBCD") 3))
  (assert-true (= (common-prefix-length "Ba", "a") 0))
  (assert-true (= (common-prefix-length "aBC", "DaBC") 0))
  (assert-true (= (common-prefix-length "aXbXc", "aXc") 2))
  (assert-true (= (common-prefix-length "aaaXccc", "aaaXbbbXccc") 4)))

;; Constants

(las3r.core/in-ns 'psymacs.config)
(las3r.core/refer 'las3r.core :exclude '(run-tests))

;; formats make the textfield slower, so use default format as much
;; as possible.

(let [default (new flash.text.TextFormat nil nil 0x000000)]
  (def formats
       {:other       default ;; default token format
        :whitespace  default ;(new flash.text.TextFormat nil nil 0xa0a0a0 false) ;; used on whitespace (and commas)
        :regex       (new flash.text.TextFormat nil nil 0x00aa22)
        :string      (new flash.text.TextFormat nil nil 0xaa8800)
        :unmatched   (new flash.text.TextFormat nil nil 0xff0000)
        :char        (new flash.text.TextFormat nil nil 0xccaa44)
        :comment     (new flash.text.TextFormat nil nil 0xcc2200)
        :lbracket    default ;(new flash.text.TextFormat nil nil 0x005577 true)
        :rbracket    default ;(new flash.text.TextFormat nil nil 0x005577 true)
        :keyword     (new flash.text.TextFormat nil nil 0x008888)
        :int         (new flash.text.TextFormat nil nil 0x440088)
        :float       (new flash.text.TextFormat nil nil 0x8800cc)
        :ratio       (new flash.text.TextFormat nil nil 0xcc00ff)}))

(def *bracket-match-color* 0xAAAAAA)
(def *bracket-mismatch-color* 0xFF0000)
(def *current-sexp-color* 0x0000FF)
(def *output-cmd-color* 0x808080)
(def *output-color* 0x000000)
(def *error-color* 0xC00000)

;; This is a parser/highlighter for las3r syntax.

;; Since paring a large string can be slow, the parser is designed to
;; work on a token-by-token basis. The parse-next function takes a
;; parser-state, parses a single token, and returns an updated parser
;; state (which contains a vector of all parsed tokens). It should be
;; called several times per frame, to simulate a background thread.

;; Parser structures (maps) come in two flavors, a string parser and a
;; textfield parser. Textfield parsers are string parsers with a
;; :textfield key linking them to a textfield object.

;; A parser map contains these keys:
;;   :text             - the string being parsed.
;;   :tokens           - a vector of parsed tokens (more details below).
;;   :textfield        - a textfield object (textfield-parsers only).
;;   :done             - set to true when parser is finished.

;; A parsed token (also a map) looks like this:
;;   :type          - token type (keyword).
;;   :string        - the actual content of the token.
;;   :index         - char index of the token in the parser's string.
;;   :open-lbrackets - a list of all *open* lbrackets for the current parse-index.
;;   :bracket-pairs  - a vector of token indices pairs {:l int, :r int}, 
;;                    contains all the matching brackets found so far, 
;;                    ordered by the token index of the closing rbracket.
;;   :next-index    - char index of the next token (might not exist, or be parsed yet).

;; :bracket-pairs exists to speed up paren-matching and
;; context-sensitive help in the editor.

;; In order to fake being fast, when a textfield is changed, the
;; parser will skip the already parsed tokens and start at the changed
;; position (hopefully the cursor -- see update-tfp code). This means
;; we need to do some tricks to detect open strings and regexps, and
;; not just treat them as symbols.

(las3r.core/in-ns 'psymacs.parser)
(las3r.core/refer 'las3r.core :exclude '(run-tests))
(refer 'psymacs.config :exclude '(run-tests))
(refer 'psymacs.utils :exclude '(run-tests))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; big hairy parsing regex
(def #^{:private true}
     parser-regex #"#(\"(?:\\?+.)*?\")[gismx]*|([^\s\(\[\{\}\]\)\";,]+)|([\r\n\s,]+)|([\(\[\{])|([\)\]\}])|(\"(?:\\?+.)*?\")|(;[^\r]*)|\\(newline|tab|space|formfeed|return|u[0-9]+|[0-6]+|.)|(#?\".*)"gms)

;; these map to the big hairy regex matches
(def #^{:private true}
     basic-token-types [:regex :other :whitespace :lbracket :rbracket :string :comment :char :unmatched])

(defn- basic-parse
  "Initial token parser, helper for the parse fn."
  [s idx]
  (set! (. parser-regex lastIndex) idx)
  (let [m (. parser-regex (exec s))]
    (when m
      {:type (loop [m (rest m) t basic-token-types]
               (if (first m) 
                 (first t) 
                 (recur (rest m) (rest t))))
       :string (first m)
       :index idx
       :next-index (. parser-regex lastIndex)})))

(defn- parse
  [s idx]
  (let [token (basic-parse s idx)]
    (when token
      (if (= (token :type) :other) ;; handle numbers and keywords
        (let [reader (. *runtime* lispReader) ;; use LispReader's number matching regexes
              ts (token :string)]
          (assoc token :type
                 (cond (= (first ts) ":") :keyword
                       (re-match (. reader intPat)   ts) :int
                       (re-match (. reader floatPat) ts) :float
                       (re-match (. reader ratioPat) ts) :ratio
                       :else :other)))
        token))))

(defn- parse-index
  "Returns the position of the first unparsed char."
  [parser]
  (if (seq (parser :tokens))
    ((vlast (parser :tokens)) :next-index)
    0))

;; highlighting and textfield connectors

(defn string-parser [s]
  {:text s
   :tokens []})

(defn last-token 
  "Takes parser, returns the last parsed token."
  [p]
  (vlast (p :tokens)))

(defn textfield-parser [tf]
  (assoc (string-parser (. tf text)) :textfield tf))

(defn char->token-index 
  "Returns the token index of the token at char-idx, or nil. "
  [parser char-idx]
  (let [token-idx (binary-search (parser :tokens)
                                 (fn [t]
                                   (<= (t :next-index) char-idx)))]
    (when token-idx ;; might be nil
      (if (>= char-idx (get-in parser [:tokens token-idx :next-index])) ;; if we're outside the token's range
        (and (parser :done) ;; char might not be parsed yet in which case we return nil,
             token-idx) ;; or we could be in an unparsable end-of-string section, so we return the last token's idx.
        token-idx))))

(defn content-changed? 
  "Returns true if the textfield's content has been updated since the last call to parse-and-highlight-next!."
  [tfp]
  (not (= (tfp :text) (. (tfp :textfield) text))))

(defn update-tfp
  "Returns an up-to-date parser (in case the textfield's content has changed)."
  [tfp]
  (if (content-changed? tfp)
    (assoc (let [cpl (common-prefix-length (. (tfp :textfield) text) (tfp :text))]
             (if (> cpl (parse-index tfp))
               tfp
               (let [last-good-token-idx (dec (char->token-index tfp (max 0 (dec cpl))))]
                 (if (and last-good-token-idx
                          (> last-good-token-idx 0))
                   (merge tfp
                          {:tokens (subvec (tfp :tokens) 0 last-good-token-idx)
                           :done false})
                   (textfield-parser (tfp :textfield))))))
      :text (. (tfp :textfield) text))
    tfp))

(defn parse-next
  "Parses the next n (1 by defualt - must be positive) tokens, returns updated parser."
  ([parser]
     (parse-next parser 1))
  ([parser n]
     (if (> n 1)
       (recur (parse-next parser 1) (dec n))
       (if (parser :done)
         parser
         (if-let token (parse (parser :text) (parse-index parser)) ;; get next token
           (let [type (token :type)
                 tokens (parser :tokens)
                 cnt (count tokens)
                 prev (vlast tokens)
                 
                 [p-type p-olbs p-bps] 
                 (if (seq prev)
                   [(prev :type) (prev :open-lbrackets) (prev :bracket-pairs)]
                   [nil '() []])

                 ;; new open-lbrackets list
                 olbs (cond (= p-type :lbracket)
                            (cons (dec cnt) p-olbs)
                            
                            (= p-type :rbracket)
                            (rest p-olbs)
                            
                            :else
                            p-olbs)
                 ;; new bracket-pairs vector
                 bps (if (and (= type :rbracket) (seq olbs))
                       (conj p-bps {:l (first olbs) :r cnt})
                       p-bps)

                 token (assoc token :open-lbrackets olbs :bracket-pairs bps)]
             (assoc parser :tokens (conj tokens token)))
           (assoc parser :done true))))))

(defn parse-all [parser]
  (if (parser :done)
    parser
    (recur (parse-next parser))))

(defn highlight-last!
  "Highlights the last parsed token."
  [tfp]
  (let [token (vlast (tfp :tokens))
        tf (tfp :textfield)]
    (when token
      (. tf (setTextFormat (formats (token :type))
                           (token :index)
                           (min (token :next-index)
                                (. tf length)))))))

(defn parse-and-highlight-next! 
  "Returns a new parser state."
  [tfp]
  (let [tfp (parse-next tfp)]
    (if (not (tfp :done))
      (highlight-last! tfp))
    tfp))

;; tfp helpers

(defn token-line 
  "Returns the line number on which the token starts."
  [tfp token]
  (get-line-index-of-char (tfp :textfield) (token :index)))

(defn token-col
  "Returns the column number on which the token starts."
  [tfp token]
  (let [line (token-line tfp token)
        line-start (. (tfp :textfield) (getLineOffset line))]
    (- (token :index) line-start)))

;; testing

;; (defn run-tests []
;;   (let [tf (new flash.text.TextField)
;;      tfp (textfield-parser tf)]

;;     (set! (. tf width) 300)
;;     (set! (. tf height) 300)
;;     (set! (. tf x) 500)
;;     (set! (. tf y) 100)
;;     (set! (. tf background) true)
;;     (set! (. tf backgroundColor) 0xeeeeee)
;;     (set! (. tf multiline) true)
;;     (set! (. tf type) "input")
;;     (set! (. tf defaultTextFormat) (new flash.text.TextFormat "Courier New", 13, 0x000000))

;;     (. *stage* (addEventListener "enterFrame" 
;;                               (fn [_] 
;;                                 (def tfp (parse-and-highlight-next! tfp))
;;                                 #_ (psymacs/clear-mini-buffer!)
;;                                 #_ (prn (char->token-index tfp (. tf caretIndex)))
;;                                 #_ (prn "tfp:" tfp))))
;;     (. *stage* (addChild tf))))

;;(time (parse-all (string-parser (psymacs/editor-string))))


(las3r.core/in-ns 'psymacs.undo)
(las3r.core/refer 'las3r.core :exclude '(run-tests))
(refer 'psymacs.parser :exclude '(run-tests))
(refer 'psymacs.utils :exclude '(run-tests))

(def comparator (new jp.psyark.utils.StringComparator))
(defn delta [old-str new-str]
  (. comparator (compare old-str new-str))
  (let [cpl (. comparator commonPrefixLength)
        csl (. comparator commonSuffixLength)]
    {:common-prefix-length cpl
     :common-suffix-length csl
     :old-content (sanitize (subs old-str cpl (- (count old-str) csl)))}))

;; this sets the number of changes saved, not bytes like in emacs.
;; since undo changes are themselves pushed into the undo stack
;; this means the number of changes that can be backed out is
;; undo-limit/2.
(def undo-limit 1000)

(defn- trim-stack
  "Returns a trimmed undo stack."
  [stack]
  (if (> (count stack) undo-limit)
    (subvec stack (- (count stack) undo-limit))
    stack))

(defn create-undo-point 
  "Returns a buffer with  a new undo point, must be called after the 
textfield is changed and before the parser's :text is updated."
  [buffer]
  (let [tf-text (. ((buffer :parser) :textfield) text)
        parser-text ((buffer :parser) :text)]
    (if (= tf-text parser-text)
      buffer ;; return buffer if no change
      (assoc buffer :undo-stack (trim-stack (conj (buffer :undo-stack) (delta parser-text tf-text)))))))

(defn undo! 
  "Updates texfield and returns a new buffer."
  [buffer]
  (let [{stack :undo-stack depth :undo-depth parser :parser} buffer
        tf (parser :textfield)
        stack-last (dec (count stack))]
    (if (and (seq stack)
             (<= depth stack-last))
      (let [delta (nth stack (- stack-last depth))
            start (delta :common-prefix-length)
            end (- (. tf length) (delta :common-suffix-length))
            old-text (delta :old-content)
            caret-idx (+ start (count old-text))]
        (. tf (replaceText start end old-text))
        (. tf (setSelection caret-idx caret-idx))
        (update-in (create-undo-point (assoc buffer :undo-depth (+ depth 2)))
                   [:parser] update-tfp))
      buffer)))

;;;;;;;;;;;;;;;;;;;

(las3r.core/in-ns 'psymacs.keyboard)
(las3r.core/refer 'las3r.core :exclude '(run-tests))
(refer 'psymacs.undo)

(defn event->keystroke [e]
  "Converts a KEY_DOWN event to a {:code ... :modifiers ...} map."
  (let [modifiers #{}
        modifiers (if (. e ctrlKey) (conj modifiers :ctrl) modifiers)
        modifiers (if (. e altKey) (conj modifiers :alt) modifiers)
        modifiers (if (. e shiftKey) (conj modifiers :shift) modifiers)]
    {:code (. e keyCode) :modifiers modifiers}))

;; from flash.ui.Keyboard livedocs
(def keycode->str
     {8 "BACKSPACE" 9 "TAB" 13 "ENTER" 15 "COMMAND" 16 "SHIFT" 17 "CONTROL" 18 "ALTERNATE" 20 "CAPS_LOCK" 21 "NUMPAD" 27 "ESCAPE" 32 "SPACE" 33 "PAGE_UP" 34 "PAGE_DOWN" 35 "END" 36 "HOME" 37 "LEFT" 38 "UP" 39 "RIGHT" 40 "DOWN" 45 "INSERT" 46 "DELETE" 48 "NUMBER_0" 49 "NUMBER_1" 50 "NUMBER_2" 51 "NUMBER_3" 52 "NUMBER_4" 53 "NUMBER_5" 54 "NUMBER_6" 55 "NUMBER_7" 56 "NUMBER_8" 57 "NUMBER_9" 65 "A" 66 "B" 67 "C" 68 "D" 69 "E" 70 "F" 71 "G" 72 "H" 73 "I" 74 "J" 75 "K" 76 "L" 77 "M" 78 "N" 79 "O" 80 "P" 81 "Q" 82 "R" 83 "S" 84 "T" 85 "U" 86 "V" 87 "W" 88 "X" 89 "Y" 90 "Z" 96 "NUMPAD_0" 97 "NUMPAD_1" 98 "NUMPAD_2" 99 "NUMPAD_3" 100 "NUMPAD_4" 101 "NUMPAD_5" 102 "NUMPAD_6" 103 "NUMPAD_7" 104 "NUMPAD_8" 105 "NUMPAD_9" 106 "NUMPAD_MULTIPLY" 107 "NUMPAD_ADD" 108 "NUMPAD_ENTER" 109 "NUMPAD_SUBTRACT" 110 "NUMPAD_DECIMAL" 111 "NUMPAD_DIVIDE" 112 "F1" 113 "F2" 114 "F3" 115 "F4" 116 "F5" 117 "F6" 118 "F7" 119 "F8" 120 "F9" 121 "F10" 122 "F11" 123 "F12" 124 "F13" 125 "F14" 126 "F15" 186 "SEMICOLON" 187 "EQUAL" 188 "COMMA" 189 "MINUS" 190 "PERIOD" 191 "SLASH" 192 "BACKQUOTE" 219 "LEFTBRACKET" 220 "BACKSLASH" 221 "RIGHTBRACKET" 222 "QUOTE"})

(defn keystroke->str 
  "Returns a textual representation of the keystroke object."
  [k]
  (let [m (k :modifiers)]
    (str (if (m :ctrl) "Ctrl-" "")
	 (if (m :alt) "Alt-" "")
	 (if (m :shift) "Shift-" "")
	 (keycode->str (k :code)))))

(def *kb-map* {})

(defmacro kb
  "Shortcut for flash.ui.Keyboard constants"
  [const]
  `(. flash.ui.Keyboard ~const))

(defn set-key-handler!
  "Sets a function as the handler for a specific keypress. key can be either a character or a key-code, modifiers are a sequence which can contain :ctrl, :alt and :shift."
  [key modifiers handler]
  (def *kb-map*
       (assoc *kb-map*
         {:code (if (string? key)
                  (. (. key (toUpperCase)) (charCodeAt 0))
                  key)
          :modifiers (into #{} modifiers)}
         handler)))

;;;;;;;;;;;;;;;;;;;

(las3r.core/in-ns 'psymacs.main)
(las3r.core/refer 'las3r.core :exclude '(run-tests))
(refer 'psymacs.config)
(refer 'psymacs.parser :exclude '(run-tests))
(refer 'psymacs.utils :exclude '(run-tests))
(refer 'psymacs.keyboard :exclude '(run-tests))
(refer 'psymacs.undo :exclude '(run-tests))

(import '(flash.display Sprite)
        '(flash.text TextFormat)
        '(flash.events Event)
        '(flash.net LocalConnection)
        '(jp.psyark.psycode.core TextEditUI)
        '(com.bit101.components Text InputText TextArea Window ProgressBar PushButton Label)
        '(net.hires.debug Stats))

(def *nomacs* (. (get-def "Nomacs") instance))

(defn buffer-string [buffer]
  (. ((buffer :parser) :textfield) text))

(defn buffer-tf 
  "Returns the buffer's textfield"
  [buffer]
  ((buffer :parser) :textfield))

(defn get-bracket-enclosed-tokens-at
  "Returns a vector of all tokens including l/r brackets in the sexp at pos, or nil
on failure. Doesn't check if bracket types match each other."
  [parser pos]
  (when-let token-idx (char->token-index parser pos)
    (let [tokens (parser :tokens)
          token (tokens token-idx)
          bracket-pairs ((vlast tokens) :bracket-pairs)]
      (when (seq (token :open-lbrackets))
        (when-let bp-idx (binary-search bracket-pairs ;; find 1st pair with rbracket after or at pos
                                        (fn [bp] 
                                          (< (bp :r) token-idx)))
          (let [bracket-pairs (subvec bracket-pairs bp-idx)] ;; snip irrelevant bracket pairs
            (when-let bp (some (fn [bp] (when (= (bp :l) (first (token :open-lbrackets))) bp)) bracket-pairs)
              (subvec tokens (bp :l) (inc (bp :r))))))))))

(defn get-coll-at
  "Returns a vector of all tokens including l/r brackets in the collection at pos, or nil
on failure."
  [parser pos]
  (when-let enclosed (get-bracket-enclosed-tokens-at parser pos)
    (when (matching-brackets? ((first enclosed) :string) ((vlast enclosed) :string))
      enclosed)))

(defn get-sexp-at
  "If the token at pos is of an ignorable type, scans (backward or forward, depending on 
dir, which should be inc or dec)  for the 1st good token. Returns a vector containing either
the token at pos, or all tokens including l/r brackets in the collection at pos, or nil on 
failure. Fails on mismatched brackets. By default scans backward ignoring whitespace and
comment tokens."
  ([parser pos]
     (get-sexp-at parser pos [:whitespace :comment] dec))
  ([parser pos ignored-types dir]
     (let [tokens (parser :tokens)
           ignored (into #{} ignored-types)
           tokens-cnt (count tokens)]
       (when-let token-idx (char->token-index parser pos)
         (loop [token-idx token-idx]
           (when (< -1 token-idx tokens-cnt)
             (let [token (tokens token-idx)
                   type (token :type)]
               (if (ignored type)
                 (recur (dir token-idx))
                 (cond (= type :lbracket)
                       (get-coll-at parser (inc (token :index)))

                       (= type :rbracket)
                       (get-coll-at parser (token :index))

                       :else
                       [token])))))))))

(defn highlight-current-sexp! 
  "Draws char highlights on the buffer overlay sprite."
  [buffer]
  (let [parser (buffer :parser)
        tf (parser :textfield)
        pos (clipped-caret-idx tf)
        g (. (buffer :overlay) graphics)
	highlight-char! (fn [idx color alpha]
                              (let [[x y] (char-xy tf idx)]
				(doto g
				  (beginFill color alpha)
				  (drawRect x y *char-width* *char-height*)
				  (endFill))))]
    (. g (clear))
    (when-let sexp-tokens (get-bracket-enclosed-tokens-at parser pos)
      (let [first-token (first sexp-tokens)
            last-token (vlast sexp-tokens)
            l (first-token :index)
            r (last-token :index)
            color (if (matching-brackets? (first-token :string)
                                          (last-token :string))
                    *bracket-match-color*
                    *bracket-mismatch-color*)]
        (highlight-char! l color 0.5)
        (highlight-char! r color 0.5)))
    (when-let sexp (get-sexp-at parser pos)
      (let [l ((first sexp) :index)
	    r (dec ((vlast sexp) :next-index))]
	(highlight-char! l *current-sexp-color* 0.2)
	(when-not (= l r)
	  (highlight-char! r *current-sexp-color* 0.2))))))

(defn attach-to-textfield-container
  "Returns an editor buffer. Container should have a readable textField property."
  [cont]
  (let [overlay (new Sprite)
        tf (. cont textField)]
    (. cont (addChild overlay))
    {:undo-stack []
     :undo-depth 0
     :container cont
     :overlay overlay
     :parser (textfield-parser tf)}))

(def code-pane (new TextEditUI))
(def help-pane (new TextArea))
(def out-pane (new TextArea))
(def parse-progress (new ProgressBar))
(def stats (new Stats))
(set! (. stats visible) false)
(def buffer (assoc (attach-to-textfield-container code-pane)
              :runtime *runtime*))

(defn current-fn-name [buffer]
  (let [caret-idx (. ((buffer :parser) :textfield) caretIndex)
        pos (if (= caret-idx (count (buffer-string buffer))) ;; if we're past the last char
              (max 0 (dec caret-idx)) ;; go one char back
              caret-idx)]
    (when-let token-idx (char->token-index (buffer :parser) pos)
      (let [tokens ((buffer :parser) :tokens)
            token (tokens token-idx)]
        (when-let doc-idx (some (fn [ti] 
                                  (when (= ((tokens ti) :string) "(") 
                                    (inc ti)))
                                (token :open-lbrackets))
          (let [fn-token (tokens doc-idx)]
            (when (= (fn-token :type) :other)
              (let [fn-name (fn-token :string)]
                (str fn-name)))))))))

(defn print-help
  "Like print-doc, with different formatting."
  [v]
  (try
   (println (str (ns-name (get ^v :ns)) "/" (get ^v :name) 
		 (if (get ^v :macro) " - Macro" "")))
   (prn (get ^v :arglists))
   ;; eat up whitespace in docstring
   (println "\n" (. (get ^v :doc) (replace #"\s+"g " ")))
   (catch Error e nil)))

;; TODO: search all namespaces?
(defn context-doc [buffer]
  "Shows the enclosing function's documentation in the minibuffer, searches in current *ns* and 'las3r.core."
  []
  (let [tf (. help-pane textField)]
    (set! (. tf text) "")
    (when-let name (current-fn-name buffer)
      (when-let v (or (find-var (symbol (ns-name *ns*) name))
                      (find-var (symbol 'las3r.core name)))
	(def old-out *out*) ;; debug
        (binding [*out* (new com.las3r.io.OutputStream (. tf appendText))]
          (print-help v))
	(when-not (= *out* old-out)
	  (prn "ARGHHHHH!!!!!!!!!!!!!!!!!!!1!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")))))) ;; debug

(defn update-layout! [& _]
  (let [pbh (. parse-progress height)
        w (. *stage* stageWidth)
        h (- (. *stage* stageHeight) pbh)
        ch (* h 4/5)]  ;; code pane height
    (mset! parse-progress [y h width w])
    (set! (. stats x) (- w (. stats width)))

    (mset! code-pane [x 0       y 0       width w              height ch])
    (mset! help-pane [x 0       y ch      width (/ w 2)        height (- h ch)])
    (mset! out-pane  [x (/ w 2) y ch      width (dec (/ w 2))  height (- h ch)]))
  (position-overlay! buffer))

(defn set-out-color! [color]
  (let [tf (. out-pane textField)
	fmt (new TextFormat)]
    (set! (. fmt color) color)
    (set! (. tf defaultTextFormat) fmt)))

(defmacro repeat-until
  "Executes body repeatedly (for side-effects) until condition is met."
  [condition & body]
  `(loop []
     (when-not ~condition
       ~@body
       (recur))))

(def #^{:private true} *prev-scrollv* nil)
(def #^{:private true} *prev-scrollh* nil)
(def #^{:private true} *prev-position* nil)
(def #^{:private true} *ui-needs-update* false)
(def #^{:private true} *last-action-time* 0)

(def *parser-time-limit* (/ 1000 (. *stage* frameRate)))
(def *idle-time* 200)

;; textfield change event dispatchers

(def #^{:private true} ignore-change-events false)

(defn dispatch-change-event [buffer]
  (. ((buffer :parser) :textfield) (dispatchEvent (new flash.events.Event "change" true))))

(defn dispatch-ignorable-change-event [buffer]
  (def #^{:private true} ignore-change-events true)
  (. ((buffer :parser) :textfield) (dispatchEvent (new flash.events.Event "change" true)))
  (def #^{:private true} ignore-change-events false))

(def #^{:private true} prevent-next-input false)

(def changed? false)

;; in principle this should also trigger a full buffer highlight invalidation, 
;; since pasting identical text will remove the formatting and won't be 
;; noticed by update-tfp. but it's not worth the cpu cost imo.
(defn- change-handler [& _]
  (when-not ignore-change-events
    (def changed? true)
    ;; sanitize (cleanup tabs and CRLFs)
    ;; don't touch anything before the 1st bad char, text might already be highlighted
    (let [text (buffer-string buffer)
          first-crlf (. text (indexOf "\r\n"))
          first-tab (. text (indexOf "\t"))]
      (when (or (pos? first-crlf) (pos? first-tab)) ;; if bad chars found
        (let [bad-idx ((if (and (pos? first-crlf) (pos? first-tab))
                         min
                         max) first-crlf first-tab) ;; first bad char idx
              bad-str (subs text bad-idx)
              good-str (sanitize bad-str)]
          (. ((buffer :parser) :textfield) (replaceText bad-idx (count text) good-str)))))
    ;; update parser
    (def buffer (assoc (create-undo-point buffer) :undo-depth 0))
    (assoc! buffer :parser (update-tfp (buffer :parser)))))

(defn- frame-handler [_]
  ;; key-down-handler will set this on non-printables too, so we disable it on each frame.
  (def #^{:private true} prevent-next-input false)

  (let [tf ((buffer :parser) :textfield)
        moved? (not= (. tf caretIndex) *prev-position*)
        scrolled? (not (and (= (. tf scrollV) *prev-scrollv*)
                            (= (. tf scrollH) *prev-scrollh*)))
        time (get-timer)
        busy? (< (- time *last-action-time*) *idle-time*)]
    (when-not busy?
      (when-not ((buffer :parser) :done)
        (let [limit (+ time *parser-time-limit*)]
          (repeat-until (or (> (get-timer) limit)
                            ((buffer :parser) :done))
                        (assoc! buffer :parser (parse-and-highlight-next! (buffer :parser)))))

        (when (seq ((buffer :parser) :tokens))
          (let [buffer-length (. tf length)]
            (mset! parse-progress [maximum buffer-length
                                   value (if ((buffer :parser) :done)
                                           buffer-length
                                           ((vlast ((buffer :parser) :tokens)) :next-index))]))))
      (when *ui-needs-update*
        (def #^{:private true} *ui-needs-update* false)
        (position-overlay! buffer)
        (highlight-current-sexp! buffer)
        (context-doc buffer)))

    (when (or changed? moved? scrolled?)
      (def changed? false)
      (def #^{:private true} *last-action-time* time)
      (def #^{:private true} *ui-needs-update* true)
      (hide-overlay! buffer)

      (def #^{:private true} *prev-scrollh* (. tf scrollH))
      (def #^{:private true} *prev-scrollv* (. tf scrollV))
      (def #^{:private true} *prev-position* (. tf caretIndex)))))


;; key handler

(def modal-window nil) ;; declare here

(let [undo-keystroke {:code (. "Z" (charCodeAt 0)) :modifiers #{:ctrl}}]
  (defn key-down-handler [event]
    (when-not modal-window ;; ignore if modal dialog is active
      (let [keystroke (event->keystroke event)]
	(if (= keystroke undo-keystroke)
	  (do
	    (def buffer (undo! buffer))
	    (def #^{:private true} prevent-next-input true)
	    (. event (preventDefault))
	    (dispatch-ignorable-change-event buffer))
	  (if-let cmd (*kb-map* keystroke)
	    (do
	      (let [orig-text (buffer-string buffer)]
		(def buffer (cmd buffer))
		(def #^{:private true} prevent-next-input true)
		(. event (preventDefault))
		(. event (stopImmediatePropagation))
		(when-not (= orig-text (buffer-string buffer))
		  (dispatch-change-event buffer))))
	    (assoc! buffer :undo-depth 0)))))))

(defn text-input-handler [event]
  (when prevent-next-input
    ;; done in enterFrame instead - (def #^{:private true} prevent-next-input false)
    (. event (preventDefault))))

;; editor displayobject
(def editor (new Sprite))

(defn set-editor-tab-and-mouse-children!
  "Enables/disables the editor's UI."
  [x]
  (mset! editor [mouseChildren x
                 tabChildren x]))

;; modal dialogs stuff
(def modal-filters 
     (to-array [(new flash.filters.ColorMatrixFilter
                     (to-array [1, 0, 0, 0, -64 
                                0, 1, 0, 0, -64 
                                0, 0, 1, 0, -64 
                                0, 0, 0, 1, 0  ]))]))

(defn- modal-close-handler [_]
  (when modal-window
    (set-editor-tab-and-mouse-children! true)
    (set! (. editor filters) nil)
    (. modal-window (removeEventListener "close" modal-close-handler))
    (. *stage* (removeChild modal-window))
    (def modal-window nil)
    (set! (. *stage* focus) (-> buffer :parser :textfield))))

(defn show-modal [w]
  "Takes a Window object, adds it to stage and makes it modal."
  [w]
  (when-not modal-window
    (def modal-window w)
    (set! (. *stage* focus) nil)
    (. w (addEventListener "close" modal-close-handler))
    (set! (. w hasCloseButton) true)
    (. *stage* (addChild w))
    (set! (. editor filters) modal-filters)
    (set-editor-tab-and-mouse-children! false)))

;; Shared object (local storage)

(def *so* (. flash.net.SharedObject (getLocal "backup" "/")))

(defn save-to-lso!
  "Save editor content to local storage. Returns the output of flush()."
  []
  (set! (. (. *so* data) code) (buffer-string buffer))
  (. *so* (flush)))

(defn read-lso
  "Returns code from local storage."
  []
  (. (. *so* data) code))

;; editor commands stuff ;;;;;;;;;;;;

(def *commands* {})

(defn set-command! [name command]
  (def *commands*
       (assoc *commands* name command)))

(defmacro def-command [name arg-map & body]
  "Defines an editor command (and a function of the same name)."
  `(do (defn ~name 
         ~(apply str (arg-map :doc)) ;; generate docstring from str/symbol vector -- TODO: doc viewer
         [~'buffer]
         (let [orig-text# (buffer-string ~'buffer)]
           (let [~'parser (~'buffer :parser)
                 {~'tf :textfield ~'tokens :tokens} ~'parser]
             ~@body)
           (when-not (= orig-text# (buffer-string ~'buffer)) ;; if textfield content has changed
             (dispatch-change-event ~'buffer))
           (assoc ~'buffer :undo-depth 0))) ;; return buffer and set undo depth to 0
       (set-key-handler! ~(arg-map :key) ~(arg-map :modifiers) ~name)
       (set-command! (quote ~name) 
                     (assoc (dissoc ~arg-map :key :modifiers) 
                       :fn ~name))))

(defn bound-keys-as-str
  "Returns a string describing the keys bound to func, or nil if none."
  [func]
  (let [ks (filter identity (map (fn [e] (when (= func (val e)) (key e))) *kb-map*))]
    (when (seq ks)
      (apply str (interleave (map keystroke->str ks) (repeat " "))))))

(defn command-doc 
  "Returns docs for command."
  [cmd-name]
  (let [cmd-name (symbol cmd-name)] ;; might be a string
    (when-let cmd (*commands* cmd-name)
      (str (get cmd :doc "Undocumented") "\n"
	   (if-let bound-keys (bound-keys-as-str (cmd :fn))
	     (str "Keyboard bindings: " bound-keys)
	     "No keyboard bindings.")))))

(def-command show-command-docs
  {:doc "Shows documentation for all editor commands."
   :key "h"
   :modifiers [:ctrl]}
  (let [sw (. *stage* stageWidth)
        sh (. *stage* stageHeight)
        ww (* sw 10/12)
        wh (* sh 10/12)
        window (mset! (new Window *stage* (* sw 1/12) (* sh 1/12)
                           "Editor commands")
                      [width ww
                       height wh])
        text (mset! (new TextArea (. window content) 10 10)
                    [width (- ww 20)
                     height (- wh 40)])
        docs (map (fn [name]
                    (str "Command: " name "\n"
                         (command-doc name) "\n\n"))
                    (keys *commands*))]
    (mset! text
           [editable false
            text (apply str docs)])
    (show-modal window)))

(defn- custom-indent 
  "Returns custom indentation for symbol or nil."
  [symbol-string]
  (when (or (contains? #{"assoc" "binding" "catch" "comment" "defmulti" "def" "defmacro" "defn" "defstruct" "doseq" "dotimes" "doto" "fn" "for" "implement" "let" "loop" "proxy" "struct-map"}
                       symbol-string)
            (contains? #{"when" "with" "def" "if" "defn" "def" "let"}
                       (second (re-match #"([^-]*)" symbol-string))))
    2))

(defn indent-line!
  "Indents a line (caret line by default), returns a new buffer."
  ([buffer]
     (indent-line! buffer (let [tf ((buffer :parser) :textfield)]
                            (get-line-index-of-char tf (. tf caretIndex)))))
  ([buffer line]
     (let [tf ((buffer :parser) :textfield)
           ;; indenting the last, empty line is a special case...
           on-last-empty-line? (and (= (. tf numLines) (inc line))
                                    (empty? (. tf (getLineText line)))
                                    ((buffer :parser) :done))
           on-caret-line? (= line (get-line-index-of-char tf (. tf caretIndex)))
           buffer (if on-last-empty-line?
                    (do (. tf (appendText " "))
                        (assoc buffer :parser (parse-next (update-tfp (buffer :parser)) 20)))
                    buffer)
           parser (buffer :parser)
           tokens (parser :tokens)
           line-offset (. tf (getLineOffset line))
           line-text (. tf (getLineText line))]
       ;; token refers to the 1st token on the line to be indented
       (when-let token-idx (char->token-index parser line-offset)
         (let [token (tokens token-idx)
               token-start-line (get-line-index-of-char tf (token :index))]
           ;; open-bracket is the first open bracket before the token's line
           (if-let open-bracket-idx (first (filter (fn [idx] (not= (token-line parser (tokens idx)) line))
                                                   (token :open-lbrackets)))
             (let [open-bracket (tokens open-bracket-idx)
                   bracket (open-bracket :string)
                   open-bracket-col (token-col parser open-bracket)
                   open-bracket-line (token-line parser open-bracket)
                   indentation (or (when (= bracket "(")
                                     (when-let sexp-1 (get-sexp-at parser (open-bracket :next-index)
                                                                   [:comment :whitespace] inc)
                                       (or (when-let x (custom-indent ((first sexp-1) :string))
                                             (+ open-bracket-col x))
                                           (when (= open-bracket-line (token-line parser (vlast sexp-1)))
                                             (when-let sexp-2 (get-sexp-at parser (inc ((vlast sexp-1) :next-index))
                                                                           [:comment :whitespace] inc)
                                               (when (= open-bracket-line (token-line parser (first sexp-2)))
                                                 (token-col parser (first sexp-2))))))))
                                   (inc open-bracket-col))
                   chars-to-replace (count (first (re-match #" *" line-text))) ;; number of old spaces
                   spaces (apply str (take indentation (repeat " ")))]
               (let [idx (max line-offset
                              (+ (. tf caretIndex)
                                 (- indentation chars-to-replace) ;; calculate new caret index
                                 (if on-last-empty-line? 1 0)))] ;; compensate for char added to last line
                 (. tf (replaceText line-offset 
                                    (+ line-offset chars-to-replace)
                                    spaces))
                 (when on-caret-line? ;; do we need to move the caret?
                   (. tf (setSelection idx idx)))))
             (if on-last-empty-line? ;; if we added an extra space
               (let [len (. tf length)]  ;; remove it
                 (. tf (replaceText (dec len) len ""))))))))
     buffer))

(def-command indent-current-line
  {:doc "Auto-indent the current line."
   :key (kb TAB)
   :tags #{:indentation}}
  (indent-line! buffer))

(def-command move-end-of-line
  {:doc "Moves the caret to the end of the current line."
   :key "e"
   :modifiers [:ctrl]
   :tags #{:movement}}
  (let [eol (. (. tf text) (indexOf "\r" (. tf caretIndex)))
        eol (if (= eol -1) (. tf length) eol)]
    (. tf (setSelection eol eol))))

(defn insert 
  "Inserts a string into the buffer's textfield at caret position."
  [buffer s]
  (let [tf (buffer-tf buffer)
        idx (. tf caretIndex)]
    (. tf (replaceText idx idx s))))

(def-command indent-for-ret-command
  {:doc "Insert a newline and indent."
   :key (kb ENTER)
   :tags #{:indentation}}
  (insert buffer "\n")
  (let [idx (inc (. tf caretIndex))
        new-buffer (assoc buffer :parser (parse-next (update-tfp (buffer :parser)) 20))]
    (. tf (setSelection idx idx))
    (indent-line! new-buffer)))

(defn- eval-and-print [rt s]
  (save-to-lso!)
  (let [tf (. out-pane textField)]
    (set-out-color! *output-cmd-color*)
    (println (str (. (. rt (currentNS)) name) 
                  (if (not= (. s (indexOf "\r")) -1)
                    "=> \n"
                    "=> ")
                  s))
    (set-out-color! *output-color*)
    (. rt (evalStr s prn nil prn))))

(def-command eval-current-sexp
  {:doc "Evaluate the sexp at point and print the result. Unlike eval-in-remote-swf, this one works in the editor's runtime. Use this to customize the editor, define new commands, etc."
   :key "n"
   :modifiers [:ctrl]
   :tags #{:evaluation :sexps}}
  (if-let sexp (get-sexp-at parser (clipped-caret-idx tf))
    (let [s (apply str (map :string sexp))]
      (eval-and-print (buffer :runtime) s))
    (println "Can't get current sexp.")))

(def-command mark-sexp
  {:doc "Selects the current sexp."
   :key "s"
   :modifiers [:ctrl :alt]
   :tags #{:selection :sexps}}
  (when-let sexp (get-sexp-at parser (clipped-caret-idx tf))
    (. tf (setSelection ((first sexp) :index) ((vlast sexp) :next-index)))))

(def-command backward-or-up-sexp
  {:doc "Move backward across one sexp, move up and back if at sexp beginning."
   :key "b"
   :modifiers [:ctrl :alt]
   :tags #{:movement :sexps}}
  (when-let sexp (get-sexp-at parser (max 0 (dec (. tf caretIndex))))
    (let [idx ((first sexp) :index)]
      (. tf (setSelection idx idx)))))

(def-command forward-or-up-sexp
  {:doc "Move forward across one sexp, move up and forward if at sexp end."
   :key "f"
   :modifiers [:ctrl :alt]
   :tags #{:movement :sexps}}
  (when-let sexp (get-sexp-at parser
                              (min (dec (. tf length))
                                   (inc (. tf caretIndex)))
                              [:comment :whitespace]
                              inc)
    (let [idx ((vlast sexp) :next-index)]
      (. tf (setSelection idx idx)))))

(def-command kill-whitespace
  {:doc "Removes whitespace at point."
   :key "w"
   :modifiers [:ctrl]}
  (when-let idx (char->token-index parser (. tf caretIndex))
    (let [token ((parser :tokens) idx)
          {idx :index} token]
      (when (= (token :type) :whitespace)
        (. tf (replaceText idx (token :next-index) ""))
        (. tf (setSelection idx idx))))))

;; isearch

(def-command incremental-search
  {:doc "Incremental search."
   :key "f"
   :modifiers [:ctrl]}
  (let [window (mset! (new Window *stage* (- (. *stage* stageWidth) 260) (- (. *stage* stageHeight) 100)
                           "Incremental search")
                      [width 250
                       height 90])
        text (mset! (new Text (. window content) 10 10)
                    [width 230
                     height 20])
        stf (. text textField)
        label (new Label (. window content) 10 30 
                   "Use up/down arrows to move between matches.\nPress escape to quit.")

        isearch-find 
        (fn [forward? next?]
          (let [haystack (. tf text)
                needle (. stf text)
                find-fn (get-property haystack (if forward? 
                                                 "indexOf"
                                                 "lastIndexOf"))
                from (if next?
                       (if forward? 
                         (inc (. tf selectionEndIndex))
                         (dec (. tf selectionBeginIndex)))
                       (. tf selectionBeginIndex))
                idx (find-fn needle from)
                idx (if (= idx -1)
                      (find-fn needle)
                      idx)]
            (when-not (= idx -1)
              (. tf (setSelection idx (+ idx (. stf length)))))))
        
        isearch-change-handler (fn [e] (isearch-find true false))
        
        isearch-key-down-handler
        (fn isearch-key-down-handler [e]
          (let [ESC  {:code 27 :modifiers #{}}
                UP   {:code 38 :modifiers #{}}
                DOWN {:code 40 :modifiers #{}}
                k (event->keystroke e)]
            (cond (= k ESC)
                  (let [idx (. tf caretIndex)]
                    (. tf (setSelection idx idx))
                    (. *stage* (removeEventListener "keyDown" isearch-key-down-handler))
                    (. text (removeEventListener "change" isearch-change-handler))
                    (modal-close-handler nil))
                  
                  (= k DOWN) (isearch-find true true)
                  (= k UP)   (isearch-find false true))))]
    
    (set! (. stf multiline) false)
    (. *stage* (addEventListener "keyDown" isearch-key-down-handler))
    (. stf (addEventListener "change" isearch-change-handler))
    (show-modal window)
    
    (set! (. *stage* focus) stf)
    (when (= *platform* "LNX")
      ;; on linux, when we give focus to the search textfield it'll get the
      ;; last keystroke, so we need to ignore it.
      ;; TODO: use on-next instead of this...
      (. stf (addEventListener "textInput" 
			       (fn tmp [e]
				 (. e (preventDefault))
				 (. stf (removeEventListener "textInput" tmp))))))))
  
;; local connection ;;;;;;;;;;;;;;;;;

(def *parameters* (.. *nomacs* root loaderInfo parameters))
(def *send-connection* (new LocalConnection))
(def *recv-connection* (new LocalConnection))
(when-let domain (. *parameters* swfDomain)
  (prn 'swf-domain domain)
  (. *recv-connection* (allowDomain domain)))
(def *captured-image* nil)

(defn init-connections []
  (try (. *recv-connection* (connect (str "_eval-out-" (. *parameters* connToken))))
       (catch Error e (trace "Can't connect, _eval-out-" 
			     (. *parameters* connToken)
			     " is already being used by another SWF")))

  (set! (. *recv-connection* client)
	(mset! (new Object)
	       [printToStdout (fn [s] 
				(. *nomacs* (out s))
				(. *nomacs* (dispatchEvent (new Event "recv"))))
		printToStderr (fn [s] 
				(. *nomacs* (err s))
				(. *nomacs* (dispatchEvent (new Event "recv"))))
		updateCapture (fn [jpeg] ;; TODO
				(def *captured-image* jpeg)
				(print "Received captured image from eval swf."))]))

  (. *send-connection* (addEventListener "status" 
					 (fn [e]
					   (when-not (= (. e level) "status")
					     (prn "ON SEND CONNECTION: " e)))))

  (. *recv-connection* (addEventListener "status" 
					 (fn [e]
					   (when-not (= (. e level) "status")
					     (prn "ON RECV CONNECTION: " e)))))

  (. *send-connection* (addEventListener "asyncError" (partial prn "ASYNCERR ON SEND CONNECTION: ")))
  (. *recv-connection* (addEventListener "asyncError" (partial prn "ASYNCERR ON RECV CONNECTION: "))))

(defn send-to-eval-swf
  "Send code to evaluator swf."
  [code]
  (. *send-connection* (send (str "_eval-in-" (. *parameters* connToken)) "eval" code)))

(def-command eval-in-remote-swf
  {:doc "Evaluates current expression (marked in blue) in remote SWF."
   :key "j"
   :modifiers [:ctrl]}
  (save-to-lso!)
  (if-let sexp (get-sexp-at parser (clipped-caret-idx tf))
    (let [s (apply str (map :string sexp))]
      (send-to-eval-swf s))
    (println "Can't get current sexp.")))

(def eval-cancel-thunk nil)
(def-command reset-remote-swf
  {:doc "Resets remote SWF (via javascript)."
   :key "r"
   :modifiers [:ctrl :alt]}
  (let [ei flash.external.ExternalInterface]
    (when (. ei available)
      ;; if we're already waiting for a reset, cancel the previous eval command
      (when eval-cancel-thunk (eval-cancel-thunk))
      (. ei (call "resetEvalSWF")))))

(def-command eval-buffer-in-new-remote-swf
  {:doc "Resets remote SWF and evaluates the current buffer."
   :key (kb ENTER)
   :modifiers [:ctrl]}
  (save-to-lso!)
  (reset-remote-swf buffer)
  (def eval-cancel-thunk
       (on-next *nomacs* "recv" ;; wait for input on recv connection
		(def eval-cancel-thunk nil)
		(send-to-eval-swf (. tf text)))))

;;;;

(def-command restore-backup
  {:doc "Restores code saved to local storage (code is saved before every eval operation)."
   :key "r"
   :modifiers [:ctrl]}
  (set! (. tf text) (sanitize (read-lso))))

(def-command toggle-stats
  {:doc "Shows/hides player stats."
   :key "q"
   :modifiers [:ctrl :alt]}
  (set! (. stats visible) (not (. stats visible))))

;; Drupal interface

(defmacro with-remote-response
  "RPC helper - conn is the connection, rpc is a standard function call form. Inside body response is bound to the response object and error? is true if an error occured."
  [conn rpc & body]
  `(let [handler# (fn [~'error? ~'response]
                    ~@body)
         responder# (new flash.net.Responder (partial handler# false) (partial handler# true))]
     (. ~conn (call ~(str (first rpc)) responder# ~@(rest rpc)))))

(def *nid* (int (. *parameters* nid)))
(def *uid* (int (. *parameters* uid)))
(def *fork* (= (. *parameters* fork) "true"))
(def *title* "Untitled")
(def *drupal* nil)

;; init backend connection
(when-not (nil? *nid*) ;; when there is a drupal backend to talk to
  (defn serialize
    "Las3r structure serializer for rpc, recursively converts maps to objects, vectors to arrays and anything else to a string."
    [x]
    (cond (map? x)
	  (let [obj (new Object)]
	    (doseq e x
	      (set-property! obj (serialize (key e)) (serialize (val e))))
	    obj)
	  
	  (vector? x)
	  (to-array (map serialize x))
	  
	  :else
	  (str x)))

  (def *drupal* (new flash.net.NetConnection))
  (set! (. *drupal* objectEncoding) "amf3")
  ;; TODO: find endpoint url at runtime
  (. *drupal* (connect "/services/amfphp")))

(when *drupal* ;; define these only when a backend exists
  (def-command drupal-node-load 
    {:doc "Loads code from server."}
    ;; disable UI
    (mset! *stage* [mouseChildren false
		    tabChildren false])
    ;; do rpc
    (with-remote-response *drupal* (node.get *nid*)
      ;; enable UI
      (mset! *stage* [mouseChildren true
                      tabChildren true])
      (if error?
        (do (println "Error loading node: ") (prn-props response)) ;; debug
        (do
	  (def *title* (str (when *fork* "forked from: ") (. response title)))
	  (set! (. tf text)
		(str (when *fork* (str ";; " *title* "\n"))
		     (. response body)))
	  ;; this happens after the function returns, so call change-handler to restart the parser
	  (change-handler)))))

    (def-command drupal-node-save
    {:doc "Saves code to server."
     :key "s"
     :modifiers [:ctrl]}
    (let [sw (. *stage* stageWidth)
          sh (. *stage* stageHeight)
          ww 350
          wh 200
          window (mset! (new Window *stage* (* sw 1/12) 50
                             "Save")
                        [width ww
                         height wh])
          wc (. window content)
          title (set! (. (new InputText wc 40 10 *title*) width) 300)
          status-label (new Label wc 130 30)
          ldr (mset! (new flash.display.Loader) [x 10 y 35 scaleX 0.22 scaleY 0.22])
          status (fn [s] (set! (. status-label text) s))
          
          save-node
          (fn [image-file quit?]
            (status "Saving...")
            (def *title* (. title text))
            (let [timestamp (. (new (get-def "Date")) (getTime))
                  node (mset! (new Object)
                              [title *title*
                               body (sanitize (. tf text))
                               status 1])] ;; Set to 1 for Published. O for unpublished.
              (when image-file
                (set! (. node field_capture) (serialize [image-file])))
              (if (or *fork* (zero? *nid*))
                ;; create new node
                (mset! node [created timestamp
                             type "code"
                             field_forked_from (when *fork* (serialize [{"nid" *nid*}]))])
                ;; update existing node
                (mset! node [changed timestamp
                             nid *nid*]))
   
              (with-remote-response *drupal* (node.save node)
                (if error?
                  (do (status "Error while saving!")
                      (println "Error while saving!")
                      (prn-props response)) ;; debug
                  (do (status "Saved")
                      (when (or *fork* (zero? *nid*)) ;; don't create a new node next time
                        (def *nid* (int response))
                        (def *fork* false))
                      (when quit?
                        (let [nav (get-def "flash.net.navigateToURL")
                              req (new flash.net.URLRequest (str (. *parameters* basePath) "node/" *nid*))]
                          (try (nav req "_self")
                               (catch Error e (prn e))))))))))
   
          save
          (fn [quit? & _]
            (if *captured-image*
              (let [timestamp (/ (. (new (get-def "Date")) (getTime)) 1000) ;; secs, not millisecs
                    file {"file" (. Base64Encoder (encodeByteArray *captured-image*))
                          "filepath"  "sites/default/files/capture/cap.jpg"
                          "filesize" (. *captured-image* length)
                          "timestamp" timestamp
                          "uid" *uid*
                          "filemime" "image/jpeg"}]
                (status "Saving captured image...")
                (with-remote-response *drupal* (file.save (serialize file))
                  (prn-props response) 
                  (if error?
                    (save-node nil quit?)
                    (save-node (assoc file "fid" (int response)) quit?))))
              (save-node nil quit?)))
                  
          take-capture
          (fn [& _]
            (status "Capturing...")
            (set! (.. *recv-connection* client updateCapture)
                  (fn [jpeg]
                    (status "")
                    (def *captured-image* jpeg)
                    (. ldr (loadBytes jpeg))))
            (. *send-connection* (send (str "_eval-in-" (. *parameters* connToken)) "capture")))
          
          save-btn (new PushButton wc 240 150 "Save & Quit" (partial save true))
          save-btn (new PushButton wc 125 150 "Save" (partial save false))
          capture-btn (new PushButton wc 10 150 "Update capture" take-capture)]
      (new Label wc 10 10 "Title:")
      (. wc (addChild ldr))
      (if *captured-image*
        (. ldr (loadBytes *captured-image*))
        (take-capture))
      (show-modal window)))  

    (def-command quit
      {:doc "Quit editor and go to current code's view page (writes buffer to local storage before quitting)."
       :key "q"
       :modifiers [:ctrl]}
      (save-to-lso!) ;; just in case
      (let [nav (get-def "flash.net.navigateToURL")
	    req (new flash.net.URLRequest (str (. *parameters* basePath) "node/" *nid*))]
	(try (nav req "_self")
	     (catch Error e (prn e)))))
)
  
;;;;

(defn init []
  (init-connections)
  (let [tf ((buffer :parser) :textfield)
        make-printer (fn [color add-newline?]
                       (fn [s]
			 (set-out-color! color)
                         (let [tf (. out-pane textField)]
                           (. tf (appendText (sanitize s)))
                           (set! (. tf scrollV) (. tf maxScrollV))
			   (when add-newline?
			     (. tf (appendText "\n"))))
			 (set-out-color! *output-color*)))]
    (doseq obj [code-pane help-pane out-pane parse-progress stats]
      (. editor (addChild obj)))

    (set! (. tf alwaysShowSelection) true)

    (. *stage* (addChild editor))

    (. *stage* (addEventListener "resize" update-layout!))
    (. tf (addEventListener "keyDown" key-down-handler))
    (. tf (addEventListener "textInput" text-input-handler))
    (. tf (addEventListener "change" change-handler))
    (. *stage* (addEventListener "enterFrame" frame-handler))

    ;; setup out and err streams
    (set! (. *nomacs* out) (make-printer *output-color* false))
    (set! (. *nomacs* err) (make-printer *error-color* true))

    (measure-font! tf)
    (update-layout!)

    ;; load node via rpc
    (when (and *drupal*
	       (pos? *nid*)) ;; when there's a node that should be loaded (0 means new node)
      (set! (.. code-pane textField text) "Loading code...")
      (drupal-node-load buffer))

    ))

(defn deinit [] ; for debugging purposes
  (. *stage* (removeEventListener "resize" update-layout!))
  (. *stage* (removeEventListener "enterFrame" frame-handler)))

(init)
